# Параграф 5: Оновлення та збірка ядра

::: warning **Увага!**
Для оновлення ядра, вам потрібен хоча б середній рівень знань того, як же працює ядро (див. [що таке ядро](/ua/Chapter3/c3p4)) і загалом Android, а також уміння користуватися git (див. [ходові команди git](/ua/Chapter2/c2p2)).
:::

## Оновлення

### Підготовка

Давайте, для початку дізнаємося, які стабільні версії ядра Android на даний момент *(2022 р.)* активно оновлюються. Ось список для наочності: *4.9, 4.14, 4.19, 5.4, 5.10, 5.15*. Повинен одразу попередити, що оновити ядро, припустимо, з 4.9 до 4.19 без перебазування неможливо, ба більше, зазвичай виробник робить специфічні драйвери пристрою тільки для однієї версії і не оновлює далі, а так само саме ядро може не підтримувати ваш чипсет і без поглиблених знань у ядрі оновити драйвери у вас не вийде. Тому, найчастіше, маінтейнери оновлюють **sublevel** ядра, це ми і будемо робити нижче. Щоб дізнатися його, заходимо у вихідник ядра, яке хочемо оновити, у корені знаходимо і відкриваємо файлик `Makefile`, у самому верху *(зазвичай)* бачимо таку картину:

```
VERSION = 4
PATCHLEVEL = 9
SUBLEVEL = 337
EXTRAVERSION =
NAME = Roaring Lionus
```

::: tip 
Або просто заходимо на своєму смартфоні в Налаштування > Про Телефон *(тільки якщо на смартфоні встановлено те саме ядро, вихідні коди якого ви збираєтеся оновити)*.
:::

Дізналися. Після цього потрібно знайти репозиторій загального *(common)* ядра, з якого і будемо оновлювати, зазвичай використовують https://android.googlesource.com/kernel/common/, але можна й інші дзеркала. Наприклад https://git.codelinaro.org/clo/la/kernel/msm *(тільки для Qualcomm)*.

Дивимося в список бранчів і вибираємо зі своєю версією ядра:

![KernelBranch](/Chapter4/KernelBranch.png)

Після чого дивимося на назву останнього комміту, має бути щось на кшталт `Merge <версія ядра>`, якщо sublevel вищий, ніж у ваших у вихідних кодах, тоді можна продовжувати. Якщо ж ні, то вітаю, у вас остання версія

### Завантажуємо репозиторії

Для прикладу, я буду використовувати [4.9.268](https://github.com/PixelExperience-Devices/kernel_lenovo_sdm710/tree/81bad83b39681cc137d99a1b613839032dab9184) ядро від Lenovo Z5s *(jd2019)* і оновлю його до [4.9.319](https://github.com/PixelExperience-Devices/kernel_lenovo_sdm710/tree/76e4fbb527d37378bac0a982c3df9551f17dbfe7). Також, для зручності, рекомендую використовувати [GitHub Desktop](https://github.com/shiftkey/desktop), хоч у ньому і не присутній весь функціонал.

1. Для початку нам потрібно склонувати вихідні коди свого ядра *(описувати, як це робити, я думаю, не потрібно)*, після цього додаємо репозиторій до GitHub Desktop *(знову ж таки, це не обов'язково, всі дії можна виконати тільки через git)*.

2. Потім, відкриваємо термінал у директорії з вихідними кодами вашого ядра і додаємо наш віддалений репозиторій загального ядра командою:
   ```bash
   git remote add common url 
   ```

   `common` - назва, можете використовувати будь-яку іншу
   `url` - посилання на репозиторій

3. Тепер фетчимо доданий репозиторій:
   ```bash
   git fetch common
   ```
   ::: tip 
   Якщо вам ліньки або не дає змоги інтернет завантажити весь репозиторій, можете наприкінці команди додати назву бранча, тоді завантажуватиметься тільки він.
   :::

### Мержим зміни

Оновлювати ядро найкраще по одному саблевелу - так більший шанс зрозуміти, в якій версії та комітеті проблема, якщо у вас будуть помилки під час збірки, або в самій системі, я ж ризиковий і робив одразу по п'ять *(про що потім пошкодував)*.

1. Знаходимо потрібну нам версію за допомогою пошуку в розділі тегів:
   ![SHA](/Chapter4/sha.png)

2. Копіюємо SHA і мержимо цей коміт у нашому бранчі:
   ```bash
   git merge sha
   ```
   
   Якщо жодних конфліктів немає, то можете помержити ще кілька. Але знову ж таки, ви не знатимете, на якій версії у вас все поламалося, тож краще міряти по одному-два і збирати, якщо ядро зібралося і система запустилася, то переходимо до наступних саблевелів.
   
### Фиксим конфликты

Тут усе досить муторно. Особисто я роблю за такою схемою: якщо з'являються конфлікти, то відкриваю GitHub Desktop, за допомогою нього набагато легше знайти їх, тому що вони всі одразу відображаються разом із поламаними рядками. Якщо конфлікт простий, то фікшу вручну, якщо ж нічого не зрозуміло, то заходжу в common репо, відкриваю перегляд файлів у тимчасовій точці потрібного тега і шукаю цей конфліктний файл там, відкриваю історію комітів для нього і дивлюся, як робили там, і просто повторюю всі зміни у свій файл. Конфліктних файлів може бути дуже багато, тож наберіться терпіння і не поспішайте, тому що один зайвий рядок або помилка в тексті, і ядро у вас не збереться або не запуститься.

## Збірка ядра

### З вихідних кодів прошивки 

Цей спосіб для тих, хто вже знає як збирати прошивки тощо. Проходимо за звичайним сценарієм підготовки до збірки прошивки, тільки замість команди запуску збірки прошивки *(`mka bacon`, `make bacon` та ін.)*, пишемо `mka bootimage`.

### З директорії ядра

1. Скачайте вихідний код ядра Android і перейдіть у директорію з ним за допомогою команди:

   ```bash
   git clone <url> kernel_path
   ```
   ```bash
   cd kernel_path
   ```

2. Переконайтеся, що у вас встановлені необхідні інструменти для збірки ядра, такі як компілятор GCC/Clang, бібліотека make, інструменти для роботи з архівами *(tar, gzip і т.д.)* та інші.

3. Виберіть конфігурацію ядра, яку хочете зібрати:
   ```bash
   make defconfig
   ```
   ::: info
   Ця команда створить файл конфігурації ядра з набором опцій за замовчуванням. Звичайно ж, вибираєте свій defconfig
   :::
   ```bash
   make menuconfig
   ```
   ::: info
   Ця команда відкриє інтерактивне меню, де ви зможете вибрати потрібні опції ядра за допомогою стрілок.
   :::

4. Запустіть збірку ядра за допомогою команди:
   ```bash
   make -jN
   ```
   ::: tip
   Де N - це кількість ядер вашого процесора. Це дасть змогу прискорити збірку, оскільки вона виконуватиметься паралельно на різних ядрах.
   :::

5. Після успішної збірки ядро буде доступне в каталозі `arch/architecture/boot/`
   ::: tip
   Де architecture - це архітектура вашого пристрою, наприклад, `x86` або `arm`/`arm64`.
   :::