
msgid ""
msgstr ""
"Project-Id-Version: About Android Building\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/SUMMARY.md:3
msgid "Введение"
msgstr ""

#: src/SUMMARY.md:5
msgid "Глава 1 Начало начал"
msgstr ""

#: src/SUMMARY.md:6
msgid "Параграф 1 Выбор подходящей системы"
msgstr ""

#: src/SUMMARY.md:7
msgid "Параграф 2 Установка системы и настройка её среды"
msgstr ""

#: src/SUMMARY.md:8
msgid "Параграф 3 Качаем исходники прошивки"
msgstr ""

#: src/SUMMARY.md:9
msgid "Параграф 4 Исходники устройства"
msgstr ""

#: src/SUMMARY.md:10
msgid "Параграф 5 Инициализация и сборка"
msgstr ""

#: src/SUMMARY.md:11
msgid "Параграф 6 В завершение"
msgstr ""

#: src/SUMMARY.md:13
msgid "Глава 2 git, с чем его едят и зачем он"
msgstr ""

#: src/SUMMARY.md:14
msgid "Параграф 1 Создание аккаунта на GitHub и настройка git под свой аккаунт"
msgstr ""

#: src/SUMMARY.md:15
msgid "Параграф 2 Ходовые команды git'а"
msgstr ""

#: src/SUMMARY.md:17
msgid "Глава 3 изучение исходников устройства"
msgstr ""

#: src/SUMMARY.md:18
msgid "Параграф 1 что есть что и для чего"
msgstr ""

#: src/SUMMARY.md:19
msgid "Параграф 2 что такое дерево и сколько их должно быть"
msgstr ""

#: src/SUMMARY.md:20
msgid "Параграф 3 Что такое vendor и почему он имеет чужие библиотеки"
msgstr ""

#: src/SUMMARY.md:21
msgid "Параграф 4 Что такое ядро"
msgstr ""

#: src/SUMMARY.md:22
msgid "Параграф 5 Адаптация исходников устройства"
msgstr ""

#: src/SUMMARY.md:24
msgid "Глава 4 Обновление исходников самостоятельно"
msgstr ""

#: src/SUMMARY.md:25
msgid "Параграф 1 Дампы, vendor и proprietary-files.txt"
msgstr ""

#: src/SUMMARY.md:26
msgid "Параграф 5 Обновление и сборка ядра"
msgstr ""

#: src/SUMMARY.md:28
msgid "Глава 5 дополнительный материал, который не вошел в основную часть"
msgstr ""

#: src/SUMMARY.md:29
msgid "Параграф 1 ошибки сборки (SELinux, нехватка пакетов, ресурсов и тд)"
msgstr ""

#: src/SUMMARY.md:30
msgid "Параграф 5 список полезных утилит и приложений"
msgstr ""

#: src/Введение.md:1
msgid ""
"<p align=\"center\">\n"
"  <img src=\"images/icon.png\" width=\"128\"/>\n"
"  <p align=\"center\"><b>BookAboutBuilding</p>\n"
"</p>"
msgstr ""

#: src/Введение.md:6
msgid "## Введение"
msgstr ""

#: src/Введение.md:8
msgid ""
"Книга представляет собой исчерпывающее руководство по сборке операционной "
"системы Android из исходного кода на Linux и разбору ее работы на низком "
"уровне. Написанная в доступном и понятном стиле, она предоставляет читателям "
"уникальную возможность углубиться во внутреннюю механику Android и получить "
"полное представление о том, как функционирует эта популярная мобильная "
"платформа."
msgstr ""

#: src/Chapter1/c1p1.md:1
#: src/Chapter1/c1p1.md:1
msgid "# Параграф 1: Выбор подходящей системы  "
msgstr ""

#: src/Chapter1/c1p1.md:3
#: src/Chapter1/c1p1.md:3
msgid ""
"Людям, которые знают операционные системы Linux, этот параграф можно "
"пропустить, так как, думаю, вы и без меня все знаете."
msgstr ""

#: src/Chapter1/c1p1.md:6
#: src/Chapter1/c1p1.md:6
msgid "### Что такое Linux, и с чем его едят"
msgstr ""

#: src/Chapter1/c1p1.md:8
#: src/Chapter1/c1p1.md:8
msgid ""
"Linux - это ОС с открытым исходным кодом, разрабатываемая сообществом "
"программистовю. Ядро Linux разрабатывается независимо, а сами дистрибутивы "
"(например, Ubuntu, Fedora, Debian) создаются на его основе и дополняются "
"дополнительными программами и утилитами. В данной статье рассматривается "
"выбор дистрибутива для сборки прошивки."
msgstr ""

#: src/Chapter1/c1p1.md:11
#: src/Chapter1/c1p1.md:11
msgid "#### Почему же нельзя заниматься этим на всем привычной ОС, Windows?"
msgstr ""

#: src/Chapter1/c1p1.md:13
#: src/Chapter1/c1p1.md:13
msgid ""
"Ну, сборка на Linux считается более предпочтительной как минимум потому что "
"многих утилит нет на Windows, а те которые есть, поставляются в крайне "
"неудобной форме: архивы, установщики и т. д.  Однако есть возможность делать "
"это на Windows при помощи виртуальных машин, или же WSL на Windows 10."
msgstr ""

#: src/Chapter1/c1p1.md:15
#: src/Chapter1/c1p1.md:15
msgid ""
"**WSL** - Windows Subsystem for Linux - Фича в Windows 10/11, позволяющая "
"запускать Linux контейнеры прямо в Windows. Эти контейнеры можно установить "
"из магазина приложений (Microsoft Store). Но почти все разработчики "
"предпочитают нативный Linux, т. к. WSL может быть менее стабильным."
msgstr ""

#: src/Chapter1/c1p1.md:18
#: src/Chapter1/c1p1.md:18
msgid "### Ну что ж, приступим?"
msgstr ""

#: src/Chapter1/c1p1.md:20
#: src/Chapter1/c1p1.md:20
msgid ""
"Хорошо, если вы уже решились познать новую ОС, и начать все таки собирать "
"прошивки (и не только), то начнем выбирать дистрибутив для вас."
msgstr ""

#: src/Chapter1/c1p1.md:22
#: src/Chapter1/c1p1.md:22
msgid "Большинство дистрибутивов разделяются на несколько лагерей:"
msgstr ""

#: src/Chapter1/c1p1.md:24
#: src/Chapter1/c1p1.md:24
msgid ""
"- Debian\n"
"- Arch Linux\n"
"- Fedora Linux"
msgstr ""

#: src/Chapter1/c1p1.md:28
#: src/Chapter1/c1p1.md:28
msgid ""
"Основное различие - система управления пакетами, или **пакетный менеджер**. "
"С этим всем мы познакомимся в следующем параграфе. "
msgstr ""

#: src/Chapter1/c1p1.md:30
#: src/Chapter1/c1p1.md:30
msgid ""
"А пока, чтобы не грузить вас ненужной информацией, скажу: Debian-like "
"системы подходят для новичков, легко освоить, шанс убить систему своими "
"руками гораздо ниже, чем у второго лагеря, Arch-like же подходят для уже "
"освоившихся пользователей, более сложны в настройке."
msgstr ""

#: src/Chapter1/c1p1.md:32
#: src/Chapter1/c1p1.md:32
msgid ""
"Fedora Linux это что-то между Debian и Arch Linux по сложности. В Fedora "
"довольно сложный установщик, но более кастомизируемый, чем в Debian. С "
"коробки софта там в разы меньше, но можно подключить пользовательский "
"репозиторий с множества софта, в том числе и проприетарного."
msgstr ""

#: src/Chapter1/c1p1.md:35
#: src/Chapter1/c1p1.md:35
msgid "#### Самые популярные Debian-like системы"
msgstr ""

#: src/Chapter1/c1p1.md:37
#: src/Chapter1/c1p1.md:37
msgid ""
"- Ubuntu (https://ubuntu.com/)\n"
"- Собственно, Debian (https://www.debian.org/index.ru.html)\n"
"- Linux Mint (Основан на Ubuntu) (https://linuxmint.com/)"
msgstr ""

#: src/Chapter1/c1p1.md:41
#: src/Chapter1/c1p1.md:41
msgid ""
"Все используют Ubuntu и вам советую. Хорошая ОС для как начала, так и для "
"повседневного использования. От себя добавлю, что начинать нужно именно с "
"нее, так как проста в установке, настройке, после установки можно сразу "
"работать. Также советую Linux Mint, это та же Ubuntu, только немного с "
"другим набором программ и в фирменной оболочке Cinnamon, которая более "
"привычна для Windows-юзера."
msgstr ""

#: src/Chapter1/c1p1.md:44
#: src/Chapter1/c1p1.md:44
msgid "#### Самые популярные Arch-like системы"
msgstr ""

#: src/Chapter1/c1p1.md:46
#: src/Chapter1/c1p1.md:46
msgid ""
"- Manjaro (https://manjaro.org/)\n"
"- Arch Linux (https://www.archlinux.org/)"
msgstr ""

#: src/Chapter1/c1p1.md:49
#: src/Chapter1/c1p1.md:49
msgid ""
"Тут все немного не однозначно. С одной стороны, эти системы кушают меньше "
"ОЗУ чем Debian-like, с другой стороны если ставить, то ставить Manjaro. "
"Почему? Да потому что установка чистого Arch Linux очень, очень сложная, тем "
"более для новичков, т. к. проводится почти полностью в ручную. Представьте "
"ситуацию, вам дают загрузочную флешку с дистрибутивом, вы загружаетесь с нее "
"и видите консоль с набором утилит. Все, дальше вы сами, по мануалу. Сложно, "
"не правда-ли? А Manjaro это тот же Arch Linux со своими репозиториями и тоже "
"прост в установке, и можно сразу работать после установки, но требует "
"немного большей \"допилки напильником\" после установки. Также в Arch Linux "
"(а соответственно и в Manjaro) существует такая прекрасная штука как AUR - "
"репозиторий с исходными кодами пакетов. Там можно найти почти все, чего нет "
"в обычных репозиториях."
msgstr ""

#: src/Chapter1/c1p1.md:52
#: src/Chapter1/c1p1.md:52
msgid "#### Самые популярные Fedora-like системы"
msgstr ""

#: src/Chapter1/c1p1.md:54
#: src/Chapter1/c1p1.md:54
msgid ""
"- Fedora Linux (https://fedoraproject.org/)\n"
"- Fedora Spins (https://fedoraproject.org/spins)"
msgstr ""

#: src/Chapter1/c1p1.md:57
#: src/Chapter1/c1p1.md:57
msgid ""
"Со стороны Fedora все легко, нету множества форков, в основном есть только "
"одна ветка. Как и у Ubuntu, тут есть сборки с различными оболочками - Fedora "
"Spins. В основную поставку Fedora Linux поставляется чистый GNOME без "
"каких-то либо патчей от себя, но я не рекомендую использовать GNOME на "
"слабых или когда нужны все 100% ресурсы ПК. В нашем случае нужны желательно "
"максимум от нашего ПК, верно? Поэтому могу порекомендовать использовать "
"более легкие DE, например LXQT, LXDE, XFCE, KDE."
msgstr ""

#: src/Chapter1/c1p1.md:59
#: src/Chapter1/c1p1.md:59
msgid ""
"### Хорошо, я выбрал дистрибутив. Но тут есть различные версии с различными "
"\"оболочками\", что выбрать?"
msgstr ""

#: src/Chapter1/c1p1.md:61
#: src/Chapter1/c1p1.md:61
msgid ""
"Тут все чисто по вкусу. В каждой из оболочек есть что-то свое, какие-то "
"легковесные, какие-то красивые. Вот список основных из них:"
msgstr ""

#: src/Chapter1/c1p1.md:63
#: src/Chapter1/c1p1.md:63
msgid ""
"- Gnome (начиная с Ubuntu 18.04 используется вместо фирменной оболочки "
"Unity)\n"
"- KDE Plasma (пожалуй, самая красивая и кастомизируемая оболочка)\n"
"- Cinnamon (фирменная оболочка Linux Mint)\n"
"- XFCE (достаточно легковесная, по умолчанию не очень красивая, но это "
"решается установкой темы)\n"
"- LXQt (еще более легковесна, по умолчанию красивее XFCE, корни растут из "
"LXDE)\n"
"- LXDE (пожалуй самая легковесная оболочка из популярных. Не красиво)\n"
"- Unity (когда-то крутая оболочка, но скажем спасибо Canonical, что "
"прекратили ее развитие)"
msgstr ""

#: src/Chapter1/c1p1.md:73
#: src/Chapter1/c1p1.md:73
msgid "### Вывод"
msgstr ""

#: src/Chapter1/c1p1.md:75
#: src/Chapter1/c1p1.md:75
msgid ""
"Для новичков, или вы хотите поставить, настроить и забыть, лишь обновляя "
"пакеты, ставим только Ubuntu или что-либо на ее основе (напр. Linux Mint). "
"Если же вы уже прошаренный, то советую попробовать Arch-like. Установку и "
"настройку рассмотрим в следующем параграфе."
msgstr ""

#: src/Chapter1/c1p2.md:1
msgid "# Параграф 2: Установка и настройка системы"
msgstr ""

#: src/Chapter1/c1p2.md:3
msgid "И так, вы выбрали дистрибутив. Приступим к установке!"
msgstr ""

#: src/Chapter1/c1p2.md:6
msgid "### Для установки нам потребуется:"
msgstr ""

#: src/Chapter1/c1p2.md:8
msgid ""
"- Рабочий компьютер\n"
"- USB флэшка\n"
"- Интернет соединение"
msgstr ""

#: src/Chapter1/c1p2.md:13
msgid "### Скачиваем дистрибутив"
msgstr ""

#: src/Chapter1/c1p2.md:15
msgid ""
"Тут все просто, думаю не стоит объяснять. Просто заходите на сайт выбранного "
"дистрибутива, и скачиваете последнюю версию. Обычно скачивание прямое, но "
"иногда можно скачать через торрент, от себя советую этот способ, т. к. таким "
"способом скачается быстрее. "
msgstr ""

#: src/Chapter1/c1p2.md:17
msgid "> Ссылки на сайты основных дистрибутивов находятся в предыдущем параграфе"
msgstr ""

#: src/Chapter1/c1p2.md:19
msgid "Скачали? Тогда переходим к следующему шагу!"
msgstr ""

#: src/Chapter1/c1p2.md:22
msgid "### Записываем установщик на флэшку"
msgstr ""

#: src/Chapter1/c1p2.md:24
msgid ""
"Рассматривать метод с CD/DVD-ROM не буду, так как кто этой древностью сейчас "
"пользуется?"
msgstr ""

#: src/Chapter1/c1p2.md:26
msgid ""
"Уточню, что рассматриваться будут способы записи на Windows, так как "
"предполагается, что вы собираетесь поставить Linux второй системой/перейти "
"на него для сборки прошивок и других полезных дел."
msgstr ""

#: src/Chapter1/c1p2.md:28
msgid ""
"Так, нам нужна утилита для записи. Подойдет Etcher или тот же Rufus, без "
"разницы. Рассмотрим подробнее..."
msgstr ""

#: src/Chapter1/c1p2.md:30
msgid ""
"1. [Etcher](#Вариант-с-etcher)\n"
"2. [Rufus](#Вариант-с-rufus)\n"
"3. [Ventoy](#Вариант-с-ventoy)"
msgstr ""

#: src/Chapter1/c1p2.md:34
msgid "### Вариант с Etcher"
msgstr ""

#: src/Chapter1/c1p2.md:36
msgid ""
"Скачиваем утилиту с сайта https://www.balena.io/etcher/. Вставляем ненужную "
"флэшку в компьютер. Ну или нужную, просто предварительно скопируйте все "
"нужные вам данные с нее. Запускаем Etcher"
msgstr ""

#: src/Chapter1/c1p2.md:38
msgid ""
"<p align=\"center\">\n"
"  <img src=\"../Chapter1/images/1.png\"/>\n"
"</p>"
msgstr ""

#: src/Chapter1/c1p2.md:42
msgid "Откроется данное окно. Как видно, тут все предельно просто:"
msgstr ""

#: src/Chapter1/c1p2.md:44
msgid ""
"1. Выбираем образ дистрибутива\n"
"    2. Выбираем USB устройство\n"
"    3. Нажимаем Flash"
msgstr ""

#: src/Chapter1/c1p2.md:48
msgid ""
"<p align=\"center\">\n"
"  <img src=\"../Chapter1/images/2.png\"/>\n"
"  <img src=\"../Chapter1/images/3.png\"/>\n"
"  <img src=\"../Chapter1/images/4.png\"/>\n"
"</p>"
msgstr ""

#: src/Chapter1/c1p2.md:55
msgid "Все, загрузочная флэшка записана"
msgstr ""

#: src/Chapter1/c1p2.md:57
msgid "### Вариант с Rufus"
msgstr ""

#: src/Chapter1/c1p2.md:59
msgid "Тут все немного по-сложнее чем с Etcher, но тоже просто."
msgstr ""

#: src/Chapter1/c1p2.md:61
msgid "Скачиваем утилиту с сайта https://rufus.ie/. Запускаем..."
msgstr ""

#: src/Chapter1/c1p2.md:63
msgid ""
"<p align=\"center\">\n"
"  <img src=\"../Chapter1/images/5.png\"/>\n"
"</p>"
msgstr ""

#: src/Chapter1/c1p2.md:67
msgid "Откроется данное окно."
msgstr ""

#: src/Chapter1/c1p2.md:69
msgid ""
"1. Выбираем устройство\n"
"\n"
"2. Выбираем образ дистрибутива\n"
"\n"
"3. В случае с Linux образами без разницы какой тип разделов на флешке "
"выбирать, это имеет вес для Windows образов. Так же не имеет веса настройки "
"файловой системы.\n"
"    Вот как примерно выглядит окно после настройки\n"
"    <p align=\"center\">\n"
"      <img src=\"../Chapter1/images/6.png\"/>\n"
"    </p>\n"
"    Интересная фишка. Можно создать так называемый persist раздел прямо в "
"утилите без заморочек. Он нужен для сохранения данных/настроек на LiveUSB\n"
"\n"
"4. Нажимаем Старт\n"
"\n"
"   **Важно!** Вас спросят о способе записи образа, так как почти все образы "
"с Linux являются ISO-Hybrid образами. Не буду вдаваться в подробности, скажу "
"только что нужно **обязательно выбрать \"Запись в режиме DD-образ\"**\n"
"   <p align=\"center\">\n"
"      <img src=\"../Chapter1/images/7.png\"/>\n"
"   </p>\n"
"   \n"
"5. Соглашаемся с этим\n"
"   <p align=\"center\">\n"
"      <img src=\"../Chapter1/images/8.png\"/>\n"
"   </p>\n"
"\n"
"6. Остается только ждать...\n"
"   <p align=\"center\">\n"
"      <img src=\"../Chapter1/images/9.png\"/>\n"
"   </p>"
msgstr ""

#: src/Chapter1/c1p2.md:97
msgid "### Вариант с Ventoy"
msgstr ""

#: src/Chapter1/c1p2.md:99
msgid ""
"Ventoy - это инструмент с открытым исходным кодом для создания загрузочного "
"USB-накопителя для файлов ISO/WIM/IMG/VHD(x)/EFI.\n"
"С Ventoy не нужно форматировать диск снова и снова, достаточно скопировать "
"файлы образов на USB-накопитель и загрузить его. Можно скопировать много "
"файлов образов одновременно, и ventoy предложит меню загрузки для их выбора."
msgstr ""

#: src/Chapter1/c1p2.md:101
msgid ""
"<p align=\"center\">\n"
"  <img src=\"../Chapter1/images/16.png\"/>\n"
"  Скриншот Ventoy с меню выбора ОС\n"
"</p>"
msgstr ""

#: src/Chapter1/c1p2.md:106
msgid ""
"Именно эта утилита является самой продвинутой среди двух ранее рассмотренных "
"вариантов. Как было понятно с описания - вам следует всего лишь перекинуть "
".iso образ диска на флешку и все. Никакого форматирования вашего 1ТБ диска, "
"чтобы записать жалкие ~5гб образа, не прекрасно ли? Прекрасно."
msgstr ""

#: src/Chapter1/c1p2.md:108
msgid "**Приступаем к установке!**"
msgstr ""

#: src/Chapter1/c1p2.md:110
msgid ""
"1. Заходим на GitHub проекта, в "
"[Releases](https://github.com/ventoy/Ventoy/releases/) качаем последнюю "
"сборку\n"
"2. Распаковываем, запускаем\n"
"3. Получаем на выходе простой интерфейс, где мы выбираем диск, на который "
"будет установлен Ventoy"
msgstr ""

#: src/Chapter1/c1p2.md:113
msgid ""
"> **ВАЖНО!** Все данные с диска будут удалены/отформатированы. Не забудь-те "
"забэкапить влажные файлы"
msgstr ""

#: src/Chapter1/c1p2.md:115
msgid ""
"4. Жмем кнопку Install... Profit\n"
"5. В результате у нас появится раздел с названием Ventoy, на который можно "
"простым движением переместить образ системы.\n"
"6. Грузимся с этой флешки. "
msgstr ""

#: src/Chapter1/c1p2.md:119
msgid "После того, как мы записали флэшку, самое время установить систему!"
msgstr ""

#: src/Chapter1/c1p2.md:121
msgid "## Установка системы"
msgstr ""

#: src/Chapter1/c1p2.md:123
msgid ""
"К сожалению, раскрыть данный этап подробно я не могу ввиду технических "
"возможностей. Но в интернете очень много гайдов, и ставить ту же Ubuntu не "
"сложнее чем Windows. Установка "
"[Arch](https://wiki.archlinux.org/title/Installation_guide) "
"([GUI](https://archlinuxgui.in/tutorials.html))| "
"[Ubuntu](https://help.ubuntu.ru/wiki/ubuntu_install)"
msgstr ""

#: src/Chapter1/c1p2.md:125
msgid ""
"> Я буду очень надеяться, что мои \"коллеги\" дополнят этот раздел подробной "
"инструкцией"
msgstr ""

#: src/Chapter1/c1p2.md:127
msgid "### Настройка среды"
msgstr ""

#: src/Chapter1/c1p2.md:129
msgid "### Установка необходимых пакетов"
msgstr ""

#: src/Chapter1/c1p2.md:131
msgid ""
"- **Debian-like:**\n"
"\t```bash\n"
"\tsudo apt-get install git-core gnupg flex bison build-essential zip curl "
"zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 libncurses5 "
"lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev "
"libxml2-utils xsltproc unzip fontconfig repo python\n"
"\t```\n"
"\t\n"
"- **Arch-like:**\n"
" *Через [AUR](https://github.com/Jguer/yay#installation)*\n"
"\n"
"   ```bash\n"
"   yay -S lineageos-devel python\n"
"   ```"
msgstr ""

#: src/Chapter1/c1p2.md:143
msgid "### Настройка git"
msgstr ""

#: src/Chapter1/c1p2.md:144
msgid "Вписываем свой никнейм и почту на GitHub:"
msgstr ""

#: src/Chapter1/c1p2.md:146
msgid ""
"```bash\n"
"git config --global user.name \"Your Name\"\n"
"git config --global user.email \"you@example.com\"\n"
"```"
msgstr ""

#: src/Chapter1/c1p3.md:1
msgid "# Параграф 3: Скачиваем исходники прошивки"
msgstr ""

#: src/Chapter1/c1p3.md:3
msgid ""
"Работать будем целиком в терминале, чтобы не бегать из терминала в UI и "
"обратно."
msgstr ""

#: src/Chapter1/c1p3.md:5
msgid ""
"Создаем папку, где будет хранится наша прошивка и заходим в неё. Пусть она "
"условно будет называться LOS (сокращенное название Lineage OS), но можно "
"назвать как угодно и еще даже циферки написать :)"
msgstr ""

#: src/Chapter1/c1p3.md:7
msgid ""
"```bash\n"
"mkdir LOS\n"
"cd LOS\n"
"```"
msgstr ""

#: src/Chapter1/c1p3.md:12
msgid ""
"Отлично, теперь требуется скачать исходники прошивки. Открываем "
"github.com/LineageOS и офигеваем, какое большое там количество всего. И все "
"это качать? Да, но не вручную, а с помощью утилиты repo. Открываем "
"репозиторий [android](https://github.com/LineageOS/android) либо manifest "
"(зависит от прошивки), обычно он закреплен."
msgstr ""

#: src/Chapter1/c1p3.md:14
msgid ""
"<p align=\"center\">\n"
"    <img src=\"../Chapter1/images/15.png\"/>\n"
"</p>"
msgstr ""

#: src/Chapter1/c1p3.md:18
msgid "Ага! Первым делом в Readme видим как скачать. Замечательно :) Вводим"
msgstr ""

#: src/Chapter1/c1p3.md:20
msgid ""
"```bash\n"
"repo init -u git://github.com/LineageOS/android.git -b lineage-17.1\n"
"repo sync\n"
"```"
msgstr ""

#: src/Chapter1/c1p3.md:25
msgid ""
"> **Примечание.** Для экономии места на диске, можно использовать параметр "
"--depth=1, который говорит не скачивать всю историю измнений.\n"
"> ```bash\n"
"> repo init --depth=1 -u git://github.com/LineageOS/android.git -b "
"lineage-17.1\n"
"> ```"
msgstr ""

#: src/Chapter1/c1p3.md:30
msgid "Скачивание началось и ждем."
msgstr ""

#: src/Chapter1/c1p3.md:32
msgid ""
"> **Примечание.** Чтобы обновить исходники, введите просто в папке с "
"исходниками\n"
"> ```bash\n"
"> repo sync\n"
"> ```"
msgstr ""

#: src/Chapter1/c1p3.md:37
msgid ""
" > Если Вы хотите ограничить скорость закачивания, требуется ввести "
"количество потоков.\n"
"> ```bash\n"
"> repo sync -j#\n"
"> ```"
msgstr ""

#: src/Chapter1/c1p3.md:42
msgid ""
"Где # - количество потоков. Автор обычно вручную ставит 16 потоков для "
"быстрого скачивания. Так же существуют самые разные агрументы для этих "
"команд, подробнее: [repo "
"init](https://git-repo.info/en/docs/multi-repos/git-repo-init/) [repo "
"sync](https://git-repo.info/en/docs/multi-repos/git-repo-sync/)"
msgstr ""

#: src/Chapter1/c1p3.md:44
msgid ""
"Такой репозиторий, который мы открыли, обычно состоит из манифестов, которые "
"представляют из себя xml файлы. Один файл может подключать другие файлы, тем "
"самым не надо все хранить в одном файле, удобно. default.xml это манифест, в "
"котором хранятся все исходники AOSP и исходники AOSP, которые были "
"модифицированы командой Linege OS. В snippets/lineage.xml лежат уже "
"исходники Lineage OS за их авторством, к примеру всеми известный плеер "
"Eleven."
msgstr ""

#: src/Chapter1/c1p3.md:46
msgid ""
"И в принципе на этом параграф заканчивается, единственное, что хотелось бы "
"немного рассказать про локальные манифесты."
msgstr ""

#: src/Chapter1/c1p3.md:48
msgid ""
"Локальные манифесты это манифесты, которые были написаны вручную или "
"сгенерированы автоматически системой сборки для скачивания некоторых "
"специфичных исходников, таких как ядра, common деревья и других репозиториев."
msgstr ""

#: src/Chapter1/c1p3.md:50
msgid ""
"Они находятся в `.repo/local_manifests/`. Может будет вопрос, \"а зачем он "
"нам?\". Все просто, не нужно вводить куча команд для скачивания нескольких "
"репозиториев себе, а просто положить .xml файл, в котором описаны что, где, "
"куда нужно качать. Посмотрим на примере устройства Lenovo Z5s aka jd2019"
msgstr ""

#: src/Chapter1/c1p3.md:52
msgid ""
"```xml\n"
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<manifest>\n"
"\n"
"    <!-- Remotes -->\n"
"  <remote name=\"gitlab_jd2019\" fetch=\"https://gitlab.com/lenovo-z5s\" />\n"
"  <remote name=\"github_kernel\" fetch=\"https://github.com/jzinferno2\" />\n"
"\n"
"  <!-- DT -->\n"
"  <project name=\"device_lenovo_jd2019\" path=\"device/lenovo/jd2019\" "
"remote=\"gitlab_jd2019\" revision=\"thirteen\" />\n"
"  <project name=\"device_lenovo_sdm710-common\" "
"path=\"device/lenovo/sdm710-common\" remote=\"gitlab_jd2019\" "
"revision=\"thirteen/stable\" />\n"
"\n"
"  <!-- VT -->\n"
"  <project name=\"vendor_lenovo_jd2019\" path=\"vendor/lenovo/jd2019\" "
"remote=\"gitlab_jd2019\" revision=\"twelve\" />\n"
"  <project name=\"vendor_lenovo_sdm710\" "
"path=\"vendor/lenovo/sdm710-common\" remote=\"gitlab_jd2019\" "
"revision=\"thirteen\" />\n"
"\n"
"  <!-- KT -->\n"
"  <project name=\"kernel_lenovo_sdm710\" path=\"kernel/lenovo/sdm710\" "
"remote=\"github_kernel\" revision=\"thirteen\" />\n"
"\n"
"</manifest>\n"
"```"
msgstr ""

#: src/Chapter1/c1p3.md:74
msgid ""
"Что мы тут видим? Обычную xml-структуру. Для сборки jd2019 нам требуется "
"больше 3 репозиториев. Для начала определяем откуда качать. "
msgstr ""

#: src/Chapter1/c1p3.md:76
msgid ""
"Это так называемый `remote`. В нашем случае у нас два remote, ссылка на "
"GitLab и GitHub.\n"
"Они введут на организацию в GitLab и обычного пользователя на GitHub. "
msgstr ""

#: src/Chapter1/c1p3.md:79
msgid "Дальше указываем что скачиваем."
msgstr ""

#: src/Chapter1/c1p3.md:80
msgid ""
"```\n"
"<project name=\"device_lenovo_jd2019\" path=\"device/lenovo/jd2019\" "
"remote=\"gitlab_jd2019\" revision=\"thirteen\" />\n"
"```"
msgstr ""

#: src/Chapter1/c1p3.md:84
msgid "Рассмотрим подробнее,"
msgstr ""

#: src/Chapter1/c1p3.md:86
msgid ""
"* **name** - Название репозитория в GitHub/GitLab\n"
"* **path** - Путь, куда необходимо скачать на диск\n"
"* **remote** - Откуда качать репозиторий\n"
"* **revision** - Ветка в репозитории, можно не указывать (будет качать ветку "
"по-умолчанию)"
msgstr ""

#: src/Chapter1/c1p3.md:91
msgid "В итоге сохранил этот .xml файл как `.repo/local_manifests/jd2019.xml`"
msgstr ""

#: src/Chapter1/c1p3.md:93
msgid ""
"Как использовать этот файл? Просто пишем `repo sync` и он будет скачивать "
"наши репозитори вместе с исходниками прошивки и конечно же будет обновить "
"исходники."
msgstr ""

#: src/Chapter1/c1p4.md:3
msgid "# Параграф 4: Исходники устройства"
msgstr ""

#: src/Chapter1/c1p4.md:5
msgid ""
"Что ж, приступаем к самому интересному. Нам требуется скачать исходники "
"устройства. Рассмотрим два случая: устройство официально поддерживается "
"командой Lineage OS и устройство не поддерживается официально командой "
"Lineage OS."
msgstr ""

#: src/Chapter1/c1p4.md:7
msgid ""
"> **Примечание.** В [предыдушем параграфе](../Chapter1/c1p3.md) мы немного "
"затронули про локальный манифест"
msgstr ""

#: src/Chapter1/c1p4.md:10
msgid "### Устройство официально поддерживается"
msgstr ""

#: src/Chapter1/c1p4.md:12
msgid ""
"Тут самое банальное. Надо только скачать проприетарные библиотеки из "
"репозитория github.com/TheMuppets, где библиотеки раскиданы по "
"производителям. Скажем, у нас смартфон производства LeEco. В поиске вбиваем "
"leeco. Открываем репозиторий, копируем ссылку. Очевидно она будет выглядить "
"так:"
msgstr ""

#: src/Chapter1/c1p4.md:14
msgid ""
"```\n"
"https://github.com/TheMuppets/proprietary_vendor_leeco\n"
"```"
msgstr ""

#: src/Chapter1/c1p4.md:18
msgid ""
"Так как мы собираем Lineage OS 17.1, то нам нужно скачать ветку "
"lineage-17.1. Что ж, давайте сделаем это! Вводим следующую команду в корне "
"исходников прошивки:"
msgstr ""

#: src/Chapter1/c1p4.md:20
msgid ""
"```bash\n"
"git clone https://github.com/TheMuppets/proprietary_vendor_leeco -b "
"lineage-17.1 vendor/leeco\n"
"```"
msgstr ""

#: src/Chapter1/c1p4.md:24
msgid ""
"> Давайте разберемся, что мы ввели:\n"
">\n"
"> - `git clone` - команда на скачивание репозитория\n"
"> \n"
"> - `https://github.com/TheMuppets/proprietary_vendor_leeco` - ссылка на "
"репозиторий\n"
"> - `-b lineage-17.1` - указываем ветку, которую требуется скачать\n"
"> - `vendor/leeco` - путь, куда требуется скачать репозиторий"
msgstr ""

#: src/Chapter1/c1p4.md:32
msgid ""
"Внимание, если Ваше устройство производства Xiaomi, то скачать проприетарные "
"библиотеки можно из gitlab.com/the-muppets."
msgstr ""

#: src/Chapter1/c1p4.md:34
msgid "### Устройство официально не поддерживается"
msgstr ""

#: src/Chapter1/c1p4.md:36
msgid ""
"И так, самая первая прошивка, которую собирают на новое устройство, это "
"Lineage OS. Во всяком случае, обычно. Будем полагаться на удачу. Так что "
"открываем github.com и в поиск вбиваем"
msgstr ""

#: src/Chapter1/c1p4.md:38
msgid ""
"```\n"
"device производитель кодовое-имя\n"
"```"
msgstr ""

#: src/Chapter1/c1p4.md:42
msgid ""
"К примеру, давайте найдем исходники Xiaomi Redmi Note 4X - mido. Вводим "
"`device_xiaomi_mido`, видим n-ое количество репозиториев:"
msgstr ""

#: src/Chapter1/c1p4.md:44
msgid ""
"<p align=\"center\">\n"
"    <img src=\"../Chapter1/images/10.png\"/>\n"
"</p>"
msgstr ""

#: src/Chapter1/c1p4.md:49
msgid ""
"Самое верхнее - дерево от Lineage OS, однако там дерево максимум для Lineage "
"OS 16.0. Не подходит. Смотрим дальше. Есть дерево от Zeelog'а, у него есть "
"дерево для Lineage OS 17.1. Отлично! Берем. Скачиваем по той же схеме, что и "
"библиотеки в примере с устройством LeEco."
msgstr ""

#: src/Chapter1/c1p4.md:51
msgid ""
"> **Примечание**. Ветка lineage-17.1-4.9 предназначена для сборки Lineage OS "
"17.1 с ядром 4.9. Ветка lineage-17.1 предназначена для сборки Lineage OS "
"17.1 с ядром 3.18. (Это в случае с mido!)"
msgstr ""

#: src/Chapter1/c1p4.md:53
msgid ""
"Так-с, specific дерево скачали. По идее, если есть lineage.dependencies, то "
"система при инициализации должна подтянуть необходимые исходники. Но так как "
"автор любит все делать ручками, не везде такое работает и в принципе мы "
"учимся, поэтому открываем этот файл и смотрим:"
msgstr ""

#: src/Chapter1/c1p4.md:55
msgid ""
"```\n"
"[\n"
"  {\n"
"    \"repository\": \"android_kernel_xiaomi_mido\",\n"
"    \"target_path\": \"kernel/xiaomi/mido\"\n"
"  }\n"
"]\n"
"```"
msgstr ""

#: src/Chapter1/c1p4.md:64
msgid ""
"В случае mido здесь мы видим только ядро. Искать его не надо, открываем "
"профиль Zeelog'а и в поиск вбиваем `android_kernel_xiaomi_mido`. Уже по "
"налаженной схеме клонируем его. Куда клонировать? Можно посмотреть в "
"`lineage.dependencies`. Хотя Вы наверняка заметили некоторую тенденцию в "
"названии репозиториев и куда они были клонированы. Вернемся к тому же ядру, "
"android_**kernel_xiaomi_mido** - **kernel/xiaomi/mido**. Думаю, вопросы "
"излишни. "
msgstr ""

#: src/Chapter1/c1p4.md:66
msgid ""
"Теперь надо скачать проприетарные библиотеки. К сожалению, в "
"`lineage.dependencies` они не прописаны. Открываем профиль Zeelog'а снова и "
"ищем что-то типа `vendor_xiaomi`. Нашли? Отлично, клонируем в "
"соответствующую папку из нужной ветки. Однако если Вы работаете с другим "
"устройством, у вас может быть иначе, к примеру, репозиторий называется "
"`proprietary_vendor_lenovo_A6020`, очевидно, что клонируем в "
"`vendor/lenovo/A6020`. И если в `lineage.dependencies` есть еще что-то, то "
"тоже клонируем в соответствующие папки."
msgstr ""

#: src/Chapter1/c1p4.md:68
msgid ""
"Вообще, если есть возможность, то лучше поспрашивать у других сборщиков под "
"ВАШЕ устройство что и откуда скачать для сборки прошивки. В некоторых "
"случаях нужно и вовсе патчить исходники прошивки. К примеру, для моего Asus "
"Zenfone 2 Laser ZE500KL (Z00ED) требуется модифицировать HAL'ы."
msgstr ""

#: src/Chapter1/c1p4.md:70
msgid ""
"Исходники готовы к сборке под устройство. Приступаем к самой долгой и нудной "
"части - сборке прошивки."
msgstr ""

#: src/Chapter1/c1p5.md:1
msgid "# Параграф 5: Инициализация и сборка"
msgstr ""

#: src/Chapter1/c1p5.md:3
msgid ""
"И вот мы переходим к самому ~~интересному~~, страшному и интригующему в этой "
"главе - к сборке готовой прошивки!"
msgstr ""

#: src/Chapter1/c1p5.md:5
msgid ""
"Для начала требуется настроить окружение, что происходит посредством запуска "
"скрипта build/envsetup.sh. Тут уместна шутка \"есть два типа людей\":"
msgstr ""

#: src/Chapter1/c1p5.md:7
msgid ""
"```bash\n"
". build/envsetup.sh\n"
"```"
msgstr ""

#: src/Chapter1/c1p5.md:11
msgid ""
"```bash\n"
"source build/envsetup.sh\n"
"```"
msgstr ""

#: src/Chapter1/c1p5.md:15
msgid ""
"Да, это два варианта как запустить скрипт. Автор данного текста относит себя "
"к первому типу людей."
msgstr ""

#: src/Chapter1/c1p5.md:17
msgid ""
"Окей, теперь требуется указать системе сборки под какое устройство "
"происходит сборка. Команда должна быть следующей:"
msgstr ""

#: src/Chapter1/c1p5.md:19
msgid ""
"```bash\n"
"lunch lineage_codename-userdebug\n"
"```"
msgstr ""

#: src/Chapter1/c1p5.md:22
msgid ""
"> **Примечание!** Можно ввести команду `lunch` без каких-то либо аргументов "
"и он выведет вам списко всех устройств, которых нашел. Там может быть под "
"эмулятор Android для Android Studio, официальные устройства и под ваше "
"устройство, если вы правильно все сделали, но рекомендую делать как выше, "
"меньше проблем и быстрее"
msgstr ""

#: src/Chapter1/c1p5.md:24
msgid ""
"Где `codename` - кодовое название устройства. Не боимся, сидим и ждем, когда "
"сделает все, что требуется системе сборки."
msgstr ""

#: src/Chapter1/c1p5.md:26
msgid ""
"<p align=\"center\">\n"
"    <img src=\"../Chapter1/images/12.png\"/>\n"
"</p>"
msgstr ""

#: src/Chapter1/c1p5.md:31
msgid ""
"Отлично! Мы можем почитать почти всю информацию об устройстве, на которое "
"собираем прошивку, и немного об ОС, которая стоит на машине для сборки. "
"Теперь мы готовы собирать. И тут снова 2 варианта:"
msgstr ""

#: src/Chapter1/c1p5.md:33
msgid ""
"1) Сборка прошивки с использованием make и количеством потоков. Если не "
"указывать количество потоков, то сборка будет происходить в однопоточном "
"режиме"
msgstr ""

#: src/Chapter1/c1p5.md:35
msgid ""
"```bash\n"
"make bacon -j#\n"
"```"
msgstr ""

#: src/Chapter1/c1p5.md:39
msgid ""
"2) Сборка прошивки с использованием mka, он автоматически установит нужное "
"количество потоков для сборки"
msgstr ""

#: src/Chapter1/c1p5.md:41
msgid ""
"```bash\n"
"mka bacon\n"
"```"
msgstr ""

#: src/Chapter1/c1p5.md:45
msgid ""
"В чем разница? Об этом нам скажет "
"[Mirsaid02](https://4pda.to/forum/index.php?showuser=4383879) с 4PDA:"
msgstr ""

#: src/Chapter1/c1p5.md:47
msgid ""
"> **mka** - лучшая команда для сборки в плане качества, т.к использует "
"программу sched_tool, при сборке будет возникать меньше ошибок, выбирает для "
"каждой части сборки подходящий компилятор, но при этом сборка проходит на "
"несколько часов дольше, в зависимости от ТХ вашего ПК или ноутбука, также "
"его называют \"супер-заряженной\" версией make.\n"
">\n"
"> "
"[Пост](https://4pda.to/forum/index.php?showtopic=209610&view=findpost&p=44763389)"
msgstr ""

#: src/Chapter1/c1p6.md:1
msgid "# Параграф 6: В завершение"
msgstr ""

#: src/Chapter1/c1p6.md:3
msgid ""
"В принципе Вы научились собирать прошивку, поздравляю! Однако этого будет "
"маловато для ваших целей, не так ли? Всегда хочется собрать что-то другое, "
"что еще на ваш любимый девайс еще не запилили. А может вашу любимую прошивку "
"давно не обновляли и не добавили свежие фиксы для устройства и новые фичи по "
"типу Dirac? Если я не угадал, то это забавно вышло :) Но я уверен, Вам мало "
"просто сборки, Вы хотите чем-то выразиться среди толпы. Надеюсь, что именно "
"здесь мы научим Вас основам."
msgstr ""

#: src/Chapter1/c1p6.md:5
msgid "Ваши учителя:"
msgstr ""

#: src/Chapter1/c1p6.md:7
msgid ""
"- [**Roker2**](https://github.com/Roker2)\n"
"- [**SanyaPilot**](https://github.com/SanyaPilot)\n"
"- [**CakesTwix**](https://github.com/CakesTwix)\n"
"- [**Ultra119**](https://github.com/Ultra119)"
msgstr ""

#: src/Chapter1/c1p6.md:12
msgid ""
"Книга в данный момент времени в разработке. Если Вы уже человек с опытом и "
"хотите поделиться своими знаниями, то Welcome to the club!"
msgstr ""

#: src/Chapter1/c1p6.md:14
msgid "[Репозиторий книги](https://github.com/Roker2/BookAboutBuilding)"
msgstr ""

#: src/Chapter1/c1p6.md:16
msgid "Ваш Roker2"
msgstr ""

#: src/Chapter2/c2p0.md:1
#: src/Chapter3/c3p0.md:1
#: src/Chapter4/c4p0.md:1
msgid "# Введение"
msgstr ""

#: src/Chapter2/c2p0.md:3
msgid "Начнем с определения \"git\"."
msgstr ""

#: src/Chapter2/c2p0.md:5
msgid ""
"> Git - распределенная система управления версиями.\n"
">\n"
"> © Wikipedia"
msgstr ""

#: src/Chapter2/c2p0.md:9
msgid ""
"По факту git позволяет создавать историю изменений и манипулировать ею, тем "
"самым достигая возможности более быстро разбираться в проблеме, "
"анализировать код и т. д. Без знаний git'а будет очень сложно работать с "
"исходниками Android и в принципе в программировании, ибо инструмент ходовой "
"и бесплатный (если Вы пользовались Mercurial'ом, то скорее всего будет "
"просто освоить git) и очень полезный. Пренебрегать им нельзя ни в коем "
"случае!"
msgstr ""

#: src/Chapter2/c2p0.md:11
msgid ""
"Про название коммитов в дереве устройства и в вендоре. Обычно они имеют "
"такие название:"
msgstr ""

#: src/Chapter2/c2p0.md:13
msgid ""
"1) \"codename: part_of_tree: Name\" (пример: \"mido: mixer_paths: Remove "
"duplicate entries\");\n"
"2) \"codename: Name\" (пример: \"mido: Kang tissot s5k5e8_ofilm\");\n"
"3) \"part_of_tree: Name\" (пример: \"power: Handle Mode::LAUNCH power "
"hints\")."
msgstr ""

#: src/Chapter2/c2p0.md:17
msgid "В принципе и все, едем к основной части!"
msgstr ""

#: src/Chapter2/c2p1.md:1
msgid ""
"# Параграф 1: Создание аккаунта на GitHub и настройка git под свой аккаунт"
msgstr ""

#: src/Chapter2/c2p1.md:3
msgid ""
"Хочу сказать, что если Вы имеете аккаунт на GitHub или чем-то подобном и "
"знаете git, то это глава Вам не нужна, ибо Вы и так все знаете."
msgstr ""

#: src/Chapter2/c2p1.md:5
msgid "#### Создаем аккаунт на GitHub"
msgstr ""

#: src/Chapter2/c2p1.md:7
msgid ""
"Тут в принципе ничего сложного, просто идем на "
"[github.com](https://github.com/), вводим почту и пароль, входим, вуаля, у "
"нас есть аккаунт на GitHub. Здесь мы можем создавать свои репозитории, в том "
"числе и приватные, оценить чей-то репозиторий, подписаться на обновления "
"репозитория, подписаться на человека, искать какие-то репозитории, поставить "
"аватарку и статус :)"
msgstr ""

#: src/Chapter2/c2p1.md:9
msgid ""
"<p align=\"center\">\n"
"  <img src=\"../Chapter2/images/1.png\"/>\n"
"</p>"
msgstr ""

#: src/Chapter2/c2p1.md:13
msgid ""
"Перейдем к тому, чтобы наши коммиты (commits) и черри-пики (cherry-picks) "
"имели информацию о нас."
msgstr ""

#: src/Chapter2/c2p1.md:15
msgid ""
"И так, варианта два и они различаются лишь флагом `--global`, который "
"говорит, что информация о нас будет использоваться везде по умолчанию."
msgstr ""

#: src/Chapter2/c2p1.md:17
msgid "Пример глобальной настройки пользователя"
msgstr ""

#: src/Chapter2/c2p1.md:19
msgid ""
"```git\n"
"git config --global user.name \"John Doe\"\n"
"git config --global user.email johndoe@example.com\n"
"```"
msgstr ""

#: src/Chapter2/c2p1.md:24
msgid ""
"[Оригинал](https://git-scm.com/book/ru/v2/%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%9F%D0%B5%D1%80%D0%B2%D0%BE%D0%BD%D0%B0%D1%87%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F-%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0-Git), "
"откуда взят пример"
msgstr ""

#: src/Chapter2/c2p1.md:26
msgid ""
"`user.name` это никнейм вашего GitHub аккаунта, а `user.email` - почта, "
"которую Вы использовали при регистрации на GitHub."
msgstr ""

#: src/Chapter2/c2p2.md:1
msgid "# Параграф 2: Ходовые команды git'а"
msgstr ""

#: src/Chapter2/c2p2.md:3
msgid ""
"Здесь приведены не все команды, только необходимая база, которой я обычно "
"пользуюсь. Для чего-то специфического вперед в Google или в любой другой "
"поисковик."
msgstr ""

#: src/Chapter2/c2p2.md:6
msgid ""
">```bash\n"
">git checkout branch\n"
">```\n"
">Это переключение между бранчами."
msgstr ""

#: src/Chapter2/c2p2.md:11
msgid ""
">```bash\n"
">git clone url -b branch path/to/folder\n"
">```\n"
">Это команда для скачивания репозитория по ссылке url из ветки branch "
"(требуется флаг -b перед названием ветки) в папку path/to/folder. Ветка и "
"папка являются необязательными аргументами."
msgstr ""

#: src/Chapter2/c2p2.md:16
msgid ""
">```bash\n"
">git remote add alias_repo_name url\n"
">```\n"
">Это добавление кастомного имени для репозитория. Используется в последующем "
"для скачивания данных с указанного репозитория."
msgstr ""

#: src/Chapter2/c2p2.md:21
msgid ""
">```bash\n"
">git fetch url\n"
">git fetch alias_repo_name \n"
">```\n"
">Это скачивание данных (коммитов) с репозитория по ссылке url или с "
"репозитория, который имеет кастомное название. Тут между этими вариантами "
"есть разница. Если чисто по ссылке, то он скачает данные только о главной "
"ветке и они сотрутся после скачивания данных с другой ссылки. Второй вариант "
"скачает информацию со всех бранчей и сохранит ее. Той же командой ее можно и "
"обновить."
msgstr ""

#: src/Chapter2/c2p2.md:27
msgid ""
">```bash\n"
">git pull\n"
">```\n"
">Это автоматизированная версия git fetch. Он загружает бранч из удаленного "
"репозитория, а затем объединяет ее с текущим."
msgstr ""

#: src/Chapter2/c2p2.md:32
msgid ""
">```bash\n"
">git push\n"
">```\n"
">Это противоположность fetch (с некоторыми оговорками). Он позволяет вам "
"переместить локальную ветвь в другой репозиторий, что служит удобным "
"способом публикации коммитов. "
msgstr ""

#: src/Chapter2/c2p2.md:37
msgid ""
">```bash\n"
">git cherry-pick commit_code\n"
">```\n"
">Это перенос чужого коммита к себе в репозиторий с сохранением авторства (вы "
"указаны как человек, который перенес данный коммит), по факту очень нужная и "
"ходовая команда. Почему? Никто не любит, когда его труды вдруг почему-то под "
"чужим авторством. Придется вертеться с этим фактом в нашем деле. Будьте "
"осторожны. ;)"
msgstr ""

#: src/Chapter2/c2p2.md:42
msgid ""
">```bash\n"
">git merge branch / commit_code \n"
">```\n"
">Это слияние всех отсутствующих коммитов, либо из другого бранча, либо до "
"отдельного коммита включительно в текущий бранч. Используется чтобы собрать "
"воедино разветвленную историю."
msgstr ""

#: src/Chapter3/c3p0.md:3
msgid ""
"Как я уже говорил, приводить я буду на примере устройства Xiaomi Redmi Note "
"4X Snapdragon, он же mido, также будут приведены в пример устройства Asus "
"ZenFone 2 Laser ZE500KL/KG (Z00ED/RD или же Z00xD) и Sony Xperia Z3 Compact, "
"потому что:"
msgstr ""

#: src/Chapter3/c3p0.md:5
msgid ""
"- Они у меня есть\n"
"- Я в них разбираюсь\n"
"- Это три устройства, у которых структура деревьев разная, что дает "
"расширить немного кругозор"
msgstr ""

#: src/Chapter3/c3p0.md:9
msgid ""
"Да, сузив кругозор до трех устройств, из которых более-менее я разбираюсь "
"только в одном, можно потерять часть информации. К сожалению, это так и "
"как-то расширить свой же кругозор я не имею возможности. Надеюсь, кто-то "
"заглянет и добавит недостающую информацию :)"
msgstr ""

#: src/Chapter3/c3p1.md:1
msgid "# Параграф 1: что есть что и для чего"
msgstr ""

#: src/Chapter3/c3p1.md:3
msgid "И так, исходники устройства состоят обычно из:"
msgstr ""

#: src/Chapter3/c3p1.md:5
msgid ""
"- Kernel - ядро\n"
"- Device tree - дерево устройства\n"
"- Vendor - вендор, проприетарные библиотеки"
msgstr ""

#: src/Chapter3/c3p1.md:9
msgid ""
"Начнем с дерева. Дерево устройства - набор конфигурационных файлов "
"(конфигов) разных форматов. В дереве прописываются различные пути, конфиги "
"сборки, часто изменяющиеся конфиги, которые копируются в прошивку, исходники."
msgstr ""

#: src/Chapter3/c3p1.md:11
msgid ""
"Ядро - ядро Linux, на котором работают все Android устройства, в нем "
"содержатся различные драйвера, переменные для них, деревья для сборки ядра и "
"конфиги, которые говорят, что надо собирать в ядре."
msgstr ""

#: src/Chapter3/c3p1.md:13
msgid ""
"Вендор - набор проприетарных (уже готовых, собранные производителем или "
"кем-либо еще) библиотек устройства, которые просто копируются в устройство. "
"Вендор состоит из тех библиотек, исходников которых нет в открытом доступе."
msgstr ""

#: src/Chapter3/c3p2.md:1
msgid "# Параграф 2: что такое дерево и сколько их должно быть"
msgstr ""

#: src/Chapter3/c3p2.md:3
msgid "Повторим определение из введения."
msgstr ""

#: src/Chapter3/c3p2.md:5
msgid ""
"Дерево устройства - набор конфигурационных файлов (конфигов) разных "
"форматов. В дереве прописываются различные пути, конфиги сборки, часто "
"изменяющиеся конфиги, которые копируются в прошивку, исходники."
msgstr ""

#: src/Chapter3/c3p2.md:7
msgid ""
"Обычно дерево лежит по пути `device/vendor/devicecodename`, где `vendor` - "
"производитель, а `devicecodename` - кодовое имя устройства. Приведем пример "
"для Xiaomi Redmi Note 4X - `device/xiaomi/mido`."
msgstr ""

#: src/Chapter3/c3p2.md:9
msgid ""
"Но бывает такое, что устройства дико похожи по составляющей дерева и "
"одинаковую часть попросту переносят в отдельное общее дерево - common. Для "
"примера рассмотрим Asus ZenFone 2 Laser ZE500KL/KG и Asus ZenFone Max "
"(Z010D)."
msgstr ""

#: src/Chapter3/c3p2.md:11
msgid "Структура получается следующая - в папке `device/asus` лежат три дерева:"
msgstr ""

#: src/Chapter3/c3p2.md:13
msgid ""
"- Общее: msm8916-common\n"
"- Специфическое: Z00xD (объединенное дерево для Asus ZenFone 2 Laser ZE500KL "
"и Asus ZenFone 2 Laser ZE500KG)\n"
"- Специфическое: Z010D"
msgstr ""

#: src/Chapter3/c3p2.md:17
msgid ""
"По итогу, вся база лежит в msm8916-common, а специфика лежит в специфичных "
"деревьях."
msgstr ""

#: src/Chapter3/c3p2.md:19
msgid ""
"[Ссылка на проект](https://github.com/Asus-MSM8916) с исходниками, бранч "
"lineage-16.0."
msgstr ""

#: src/Chapter3/c3p2.md:21
msgid "Но самое смешное, что общих деревьев может быть еще больше!"
msgstr ""

#: src/Chapter3/c3p2.md:23
msgid "Приведу пример для Sony Xperia Z3 Compact:"
msgstr ""

#: src/Chapter3/c3p2.md:25
msgid ""
"- `device/sony/z3c`\n"
"- `device/sony/shinano-common`\n"
"- `device/sony/msm8974-common`\n"
"- `device/sony/common`"
msgstr ""

#: src/Chapter3/c3p2.md:30
msgid ""
"4 дерева, которые друг за другом подключаются. Важно не пропустить данную "
"информацию, иначе будет потом непонятно почему на этапе инициализации сборки "
"произошла ошибка."
msgstr ""

#: src/Chapter3/c3p2.md:32
msgid ""
"Возникает все же резонный вопрос: не проще ли все-таки все в одно дерево "
"\"запихнуть\" и не париться?"
msgstr ""

#: src/Chapter3/c3p2.md:34
msgid "И я скажу Вам нет. На то есть две причины:"
msgstr ""

#: src/Chapter3/c3p2.md:36
msgid ""
"- Если другое устройство, на которое собирается прошивка, использует общие "
"деревья, то сокращается количество действий, которое нужно совершить для "
"сборки (работает в том случае, если собирается прошивка не с нуля);\n"
"- Много времени и сил занимает добавление одного коммита в целый ряд "
"устройств, проще один коммит в одно дерево, в итоге изменение будет во всех "
"устройствах, которые используют общее дерево."
msgstr ""

#: src/Chapter3/c3p2.md:39
msgid "В итоге, получается только выгода. Похожую ситуацию мы увидим в вендоре."
msgstr ""

#: src/Chapter3/c3p3.md:1
msgid "# Параграф 3: Что такое vendor и почему он имеет чужие библиотеки"
msgstr ""

#: src/Chapter3/c3p3.md:3
msgid ""
"Vendor Tree (или просто vendor для сокращения, не путать с разделом) - набор "
"проприетарных (уже готовых, собранные производителем или кем-либо еще) "
"библиотек устройства, которые просто копируются в устройство. Vendor состоит "
"из тех библиотек, исходников которых нет в открытом доступе. В основном там "
"хранятся библиотеки, которые со стока (как правило специфичные для "
"конкретной модели) и общие, которые взяты с CAF или смартфона с необходимой "
"версией Android с таким же CPU (или из его семейства, к примеру некоторые "
"библиотеки с msm8996 будут спокойно работать на msm8953) или просто с другой "
"модели."
msgstr ""

#: src/Chapter3/c3p3.md:5
msgid ""
"Итак, стоковые библиотеки понятно почему лежат в vendor, они заточены под "
"данный смартфон. А зачем все же там лежат библиотеки, которые с других "
"устройств?"
msgstr ""

#: src/Chapter3/c3p3.md:7
msgid ""
"1) Некоторые сами по себе общие, к примеру библиотеки AptX от crosshatch "
"прекрасно чувствуют себя на mido.\n"
"2) Некоторые заточены только под конкретный CPU/семейство CPU, тем самым на "
"разных устройствах с таким же CPU/семейством CPU они будут работать без "
"проблем (не всегда).\n"
"3) Внезапно подошли, даже не смотря на их специфичность."
msgstr ""

#: src/Chapter3/c3p3.md:11
msgid ""
"Про 3-ий пункт хотелось бы подробнее, так как здесь есть маленькая история. "
"Ковыряя библиотеки mido мне стрельнуло попробовать что-то сделать с "
"chromatix-библиотеками камеры. Посмотрел какие камеры у меня на моем mido и "
"пошел смотреть модели с такими же камерами. Оказалось, что у tissot ровно "
"такая же фронталка. Не долго думая, я быстренько сделал Magisk-модуль с "
"этими библиотеками и... О чудо, камера работает! Воодушевившись, я "
"попробовал еще и eeprom-библиотеку взять. Камера тоже работает! Крутяк! "
"Далее я наткнулся на bardock, у него вроде как были библиотеки под мою "
"основную камеру. Также сделал Magisk-модуль и... Камера работает, но все в "
"красных тонах. Мда, грустно, но ладно, модуль удаляю и все возвращается на "
"круги своя."
msgstr ""

#: src/Chapter3/c3p3.md:13
msgid ""
"Вывод: иногда бывают случаи, что вот идеально все вписывается и работает, "
"хотя казалось бы специфичные библиотеки с другого устройства. С этим надо "
"быть крайне осторожным, при неизвестных последствиях можно получить "
"неисправность устройства."
msgstr ""

#: src/Chapter3/c3p4.md:1
msgid "# Параграф 4: Что такое Ядро"
msgstr ""

#: src/Chapter3/c3p4.md:3
msgid ""
"Что такое ядро? Ядро операционной системы - в данном случае Android - это "
"**компонент, который помогает вашим приложениям взаимодействовать с вашим "
"оборудованием.** Оно управляет системными ресурсами, при необходимости "
"обменивается данными с внешними устройствами и т. д. Android использует "
"вариант ядра Linux, содержит базовый набор драйверов, которые необходимы для "
"работы устройства. Поскольку ядро Android по умолчанию является производным "
"от ядра Linux, можно с уверенностью сказать, что ядро Android также является "
"[монолитным](https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%BD%D0%BE%D0%BB%D0%B8%D1%82%D0%BD%D0%BE%D0%B5_%D1%8F%D0%B4%D1%80%D0%BE). "
"Рассмотрим пример: предположим, вы установили приложение для съемки "
"фотографий. Для этого вам нужно получить доступ к камере вашего телефона. Но "
"приложение не может этого сделать. Оно не может напрямую получить доступ к "
"камере, чтобы делать фотографии. Вместо этого оно посылает запрос ядру, и "
"ядро предоставляет доступ к камере. Без ядра для приема и отправки "
"информации разработчикам пришлось бы писать код для каждого отдельного "
"события для каждого отдельного элемента ПО вашего устройства. С ядром все, "
"что им нужно делать, это взаимодействовать с ним через API системы Android, "
"а разработчикам нужно только заставить ПО устройства взаимодействовать с "
"ядром."
msgstr ""

#: src/Chapter3/c3p4.md:5
msgid ""
"<p align=\"center\">\n"
"  <img src=\"../Chapter3/images/1.png\"/>\n"
"</p>"
msgstr ""

#: src/Chapter3/c3p4.md:10
msgid "### Почему ядро должно постоянно обновляться?"
msgstr ""

#: src/Chapter3/c3p4.md:12
msgid ""
"Ядро Linux постоянно меняется. Множество улучшений попадает в ядро, чтобы "
"сделать его более надежным, безопасным и продвинутым каждый день. Вполне "
"логично, что вся эта дельта улучшений попадает в ядро Android при любой "
"возможности. Многие производители сохраняют ядро неизменным при "
"незначительном обновлении Android, в основном потому, что обновление ядра "
"(называемое BSP - Board Support package) часто приходит от производителя "
"чипсета (TI, Samsung, Qualcomm, Mediatek и т.д.). При изменении ядра для "
"обновления Android, часто требуется много тестирования и обеспечения "
"стабильности. Поэтому это часто приводит к задержке обновлений Android, а "
"иногда и к прекращении обновлений ядра, когда поставщики чипсетов не "
"поддерживают их.\n"
"Так же это объясняет, почему производители не очень часто обновляют версию "
"ядра вместе с версией Android."
msgstr ""

#: src/Chapter3/c3p4.md:17
msgid "### Дерево устройства (DT)"
msgstr ""

#: src/Chapter3/c3p4.md:19
msgid ""
"Дерево устройств (DT) - это структура данных, состоящая из именованных узлов "
"и свойств, которые описывают оборудование которое, в обычных условиях, "
"обнаружить невозможно. Операционные системы, такие как ядро Linux, "
"используемое в Android, используют DT для поддержки широкого спектра "
"аппаратных конфигураций, используемых в устройствах на базе Android. "
"Производители оборудования снабжают ядро своими собственными DT, которые "
"Linux затем компилирует в файл Device Tree Blob (DTB), используемый "
"загрузчиком."
msgstr ""

#: src/Chapter3/c3p4.md:21
msgid ""
"Оверлей дерева устройства (DTO) позволяет наложить центральный блок дерева "
"устройств (DTB) на дерево устройств. Загрузчик, использующий DTO, может "
"поддерживать DT системы-на-чипе (SoC) и динамически накладывать DT для "
"конкретного устройства, добавляя узлы в дерево и внося изменения в свойства "
"существующего дерева."
msgstr ""

#: src/Chapter3/c3p4.md:23
msgid ""
"<p align=\"center\">\n"
"  <img src=\"../Chapter3/images/2.png\"/>\n"
"</p>"
msgstr ""

#: src/Chapter3/c3p4.md:27
msgid "#### Терминология"
msgstr ""

#: src/Chapter3/c3p4.md:29
msgid ""
"* `DT` — Дерево устройства\n"
"* `DTB` — Блоб дерева устройства\n"
"* `DTBO` — Блоб дерева устройства для оверлея\n"
"* `DTC` — Компилятор дерева устройства\n"
"* `DTO` — Оверлей дерева устройства\n"
"* `DTS` — Исходник дерева устройства\n"
"* `FDT` — Сплющенное дерево устройства. Двоичный формат, содержащийся в "
"блоб-файле .dtb"
msgstr ""

#: src/Chapter3/c3p4.md:37
msgid "### Типы ядра "
msgstr ""

#: src/Chapter3/c3p4.md:39
msgid ""
"- **Android Common Kernel (ACK)**\n"
"  *Ядро, которое находится ниже ядра LTS и включает в себя исправления, "
"представляющие интерес для сообщества Android, которые не были объединены в "
"основные ядра Linux или ядра с длительной поддержкой (LTS). Более новые ACK "
"(версии 5.4 и выше) также известны как ядра GKI, поскольку они поддерживают "
"разделение кода Generic Kernel, не зависящего от аппаратного обеспечения, и "
"модулей GKI, не зависящих от аппаратного обеспечения.*\n"
"\n"
"- **Android Open Source Project (AOSP) kernel**\n"
"\n"
"- **Feature kernel**\n"
"  *Ядро, для которого гарантированно реализованы функции релиза платформы. "
"Например, в Android 12 двумя функциональными ядрами были android12-5.4 и "
"android12-5.10. Функции Android 12 не могут быть перенесены обратно на ядра "
"4.19 после обновления; набор функций будет аналогичен устройству, которое "
"было запущено с 4.19 на R и обновлено до S).*\n"
"  \n"
"- **Generic Core Kernel**\n"
"  *Часть ядра GKI, которая является общей для всех устройств*.\n"
"  \n"
"- **Generic Kernel Image (GKI) kernel**\n"
"  *Любое более новое (5.4 и выше) ядро ACK (в настоящее время только "
"aarch64). Это ядро состоит из двух частей: ядро GKI с общим для всех "
"устройств кодом и модули ядра GKI, разработанные Google, которые могут быть "
"динамически загружены на устройства, где это необходимо.*\n"
"  \n"
"- **Launch Kernel**\n"
"  *Ядро, которое подходит для запуска устройства для данного выпуска "
"платформы Android. Например, в Android 12 допустимыми ядрами для запуска "
"были 4.19, 5.4 и 5.10.*\n"
"  \n"
"- **Long Term Supported (LTS) kernel**\n"
"  *Ядро Linux, которое поддерживается от 2 до 6 лет. Ядра LTS выпускаются "
"раз в год и являются основой для каждого из ACK Google.*"
msgstr ""

#: src/Chapter3/c3p4.md:58
msgid "#### Типы ветвей ядра"
msgstr ""

#: src/Chapter3/c3p4.md:60
msgid ""
"- **ACK KMI kernel branch**\n"
"  *Ветвь, с которой собираются ядра GKI. Например, android12-5.10 и "
"android13-5.15.*\n"
"\n"
"- **Android-mainline**\n"
"  *Основная ветвь разработки для функций Android. Когда новое ядро LTS "
"объявляется выше по течению, соответствующее новое ядро GKI ответвляется от "
"android-mainline.*\n"
"\n"
"- **Linux mainline**\n"
"  *Основная ветвь разработки для вышестоящих ядер Linux, включая ядра LTS.*"
msgstr ""

#: src/Chapter3/c3p5.md:1
msgid "# Параграф 5: Адаптация исходников устройства"
msgstr ""

#: src/Chapter3/c3p5.md:3
msgid ""
"Внимание! Здесь будут общие знания и они будут касаться в основном дерева. "
"По поводу более детальной адаптации смотрите репозиторий прошивки в поисках "
"примеров и спрашивайте у поддержки."
msgstr ""

#: src/Chapter3/c3p5.md:5
msgid ""
"И так, для базы своего дерева я рекомендую взять дерево для Lineage OS. И "
"так, почему? Потому что Lineage OS реализовала некоторые фичи, которые также "
"используются в Lineage-based прошивках (логично), либо были портированы на "
"AOSP-based прошивки. К примеру:"
msgstr ""

#: src/Chapter3/c3p5.md:7
msgid ""
"- `FlipFlap` (поддержка магнитных чехлов)\n"
"- `Touch HAL` (поддержка кастомных фич тачскрина)\n"
"- `LiveDisplay HAL` (поддержка кастомной настройки дисплея)"
msgstr ""

#: src/Chapter3/c3p5.md:11
msgid "В пример возьмем дерево для mido."
msgstr ""

#: src/Chapter3/c3p5.md:13
msgid "### Общие моменты"
msgstr ""

#: src/Chapter3/c3p5.md:15
msgid ""
"Как мы уже выяснили, есть конфиг lineage_mido.mk. Его надо переименовать в "
"соответствии с прошивкой (см. другие деревья для этой прошивки). К примеру, "
"в carbon_mido.mk. Далее открываем этот файл. Находим переменную "
"PRODUCT_NAME, там будет следующий текст"
msgstr ""

#: src/Chapter3/c3p5.md:17
msgid ""
"```makefile\n"
"PRODUCT_NAME := lineage_mido\n"
"```"
msgstr ""

#: src/Chapter3/c3p5.md:21
msgid "Логично предположить, что lineage надо менять на carbon"
msgstr ""

#: src/Chapter3/c3p5.md:23
msgid ""
"```makefile\n"
"PRODUCT_NAME := carbon_mido\n"
"```"
msgstr ""

#: src/Chapter3/c3p5.md:27
msgid "Чуть выше мы увидим данный код"
msgstr ""

#: src/Chapter3/c3p5.md:29
msgid ""
"```makefile\n"
"$(call inherit-product, vendor/lineage/config/common_full_phone.mk)\n"
"```"
msgstr ""

#: src/Chapter3/c3p5.md:33
msgid ""
"Так-с, здесь надо смотреть на что менять. К примеру в CarbonROM надо вписать "
"следующий код (это для смартфонов, так как mido это смартфон, а не планшет "
"или что-то еще)"
msgstr ""

#: src/Chapter3/c3p5.md:35
msgid ""
"````makefile\n"
"$(call inherit-product, vendor/carbon/config/gsm.mk)\n"
"$(call inherit-product, vendor/carbon/config/common.mk)\n"
"````"
msgstr ""

#: src/Chapter3/c3p5.md:40
msgid ""
"Так, сохраняем, открываем AndroidProducts.mk. Сразу видим, что у нас есть "
"следующий код"
msgstr ""

#: src/Chapter3/c3p5.md:42
msgid ""
"```makefile\n"
"PRODUCT_MAKEFILES := \\\n"
"    $(LOCAL_DIR)/lineage_mido.mk\n"
"\n"
"COMMON_LUNCH_CHOICES := \\\n"
"    lineage_mido-user \\\n"
"    lineage_mido-userdebug \\\n"
"    lineage_mido-eng\n"
"```"
msgstr ""

#: src/Chapter3/c3p5.md:52
msgid ""
"Опять-таки логично подумать, что надо lineage поменять на carbon (как "
"минимум мы же переименовали lineage_mido.mk в carbon_mido.mk), это верно. "
"lineage_mido.mk меняем на carbon_mido.mk, а lineage_mido-user и т. д. меняем "
"на carbon_mido-user и т. д. (это вариации какой билд можно собрать). И "
"должно получиться нечто такое"
msgstr ""

#: src/Chapter3/c3p5.md:54
msgid ""
"```makefile\n"
"PRODUCT_MAKEFILES := \\\n"
"    $(LOCAL_DIR)/carbon_mido.mk\n"
"\n"
"COMMON_LUNCH_CHOICES := \\\n"
"    carbon_mido-user \\\n"
"    carbon_mido-userdebug \\\n"
"    carbon_mido-eng\n"
"```"
msgstr ""

#: src/Chapter3/c3p5.md:64
msgid "### Lineage OS based -> Lineage OS based"
msgstr ""

#: src/Chapter3/c3p5.md:66
msgid "По факту хватит всего того, что описано выше."
msgstr ""

#: src/Chapter3/c3p5.md:68
msgid "### Lineage OS based -> AOSP based"
msgstr ""

#: src/Chapter3/c3p5.md:70
msgid ""
"Выясняем, чего нету в прошивке. В CarbonROM к примеру нету каких либо из "
"фич, которые я перечислял в самом начале параграфа. Требуется вырезать Touch "
"HAL, LiveDisplay и FlipFlap overlay, если все это есть и этого в прошивке "
"нет. Touch HAL лежит в папке touch, LiveDisplay HAL - в папке livedisplay, "
"FlipFlap overlay - в lineage-overlay/packages/apps/FlipFlap. Все эти папки "
"вырезаем. Далее открываем файл device.mk и убираем следующий код"
msgstr ""

#: src/Chapter3/c3p5.md:72
msgid ""
"```makefile\n"
"# Touch features\n"
"PRODUCT_PACKAGES += \\\n"
"    vendor.lineage.touch@1.0-service.xiaomi_mido\n"
"```"
msgstr ""

#: src/Chapter3/c3p5.md:78
msgid ""
"```makefile\n"
"# LiveDisplay\n"
"PRODUCT_PACKAGES += \\\n"
"    vendor.lineage.livedisplay@2.0-service.xiaomi_mido\n"
"```"
msgstr ""

#: src/Chapter3/c3p5.md:84
msgid ""
"```makefile\n"
"# FlipFlap\n"
"PRODUCT_PACKAGES += \\\n"
"   FlipFlap\n"
"```"
msgstr ""

#: src/Chapter3/c3p5.md:90
msgid "Также вырезаем сборку Trust HAL (если его в прошивке нет)"
msgstr ""

#: src/Chapter3/c3p5.md:92
msgid ""
"```makefile\n"
"# Trust HAL\n"
"PRODUCT_PACKAGES += \\\n"
"    vendor.lineage.trust@1.0-service\n"
"```"
msgstr ""

#: src/Chapter3/c3p5.md:98
msgid "Сохраняем и закрываем файл."
msgstr ""

#: src/Chapter3/c3p5.md:100
msgid ""
"Теперь требуется отредактировать SEPolicy! Открываем "
"sepolicy/vendor/file_contexts и находим следующее:"
msgstr ""

#: src/Chapter3/c3p5.md:102
msgid ""
"```makefile\n"
"/(vendor|system/vendor)/bin/hw/vendor\\.lineage\\.livedisplay@2\\.0-service\\.xiaomi_mido "
"u:object_r:hal_lineage_livedisplay_qti_exec:s0\n"
"/(vendor|system/vendor)/bin/hw/vendor\\.lineage\\.touch@1\\.0-service\\.xiaomi_mido "
"      u:object_r:hal_lineage_touch_default_exec:s0\n"
"```"
msgstr ""

#: src/Chapter3/c3p5.md:107
msgid ""
"Вспоминаем, что LideDisplay HAL и Touch HAL были благополучно удалены, "
"поэтому удаляем эти две строчки, но надо убрать в SEPolicy еще и правила для "
"hal_lineage_livedisplay_qti_exec и hal_lineage_touch_default_exec. Самое "
"простое - grep'нуть все правила SEPolicy нашего дерева. Делается так:"
msgstr ""

#: src/Chapter3/c3p5.md:109
msgid ""
"```bash\n"
"grep -InRI \"place_here_searched_text\"\n"
"```"
msgstr ""

#: src/Chapter3/c3p5.md:113
msgid ""
"Таким образом мы увидим все файлы, которые имеют включение текста "
"\"place_here*_*searched_text\", надеюсь логика понятна. И так, ищем и "
"удаляем эти правила. Если файл состоит целиком из того, что относится к "
"искомым типам, то попросту удаляем (скорее всего так и будет). Уря! Готово!"
msgstr ""

#: src/Chapter3/c3p5.md:115
msgid "### AOSP based -> Lineage OS based"
msgstr ""

#: src/Chapter3/c3p5.md:117
msgid ""
"Тут по факту хватило бы общих моментов для данного дела, однако мы помним, "
"что есть такие фичи как Touch HAL и LiveDisplay HAL! Их можно написать и "
"добавить правила SEPolicy для них. Если Вы написали/портировали/перенесли "
"HAL и он работает в Permissive, то я поздравляю. Следующий шаг это добавить "
"новый HAL в file_contexts, собрать прошивку и установить ее. Далее вертим "
"HAL как можем, чтобы набрались отказы SEPolicy. Как только мы собрали все "
"отказы, сохраняем logcat и добавляем эти правила на базе собранных отказов. "
"Переводим SELinux в Enforcing, собираем, ставим и проверяем. Если все "
"работает, то я поздравляю, Вы сделали это!"
msgstr ""

#: src/Chapter3/c3p5.md:119
msgid "### Напоследок"
msgstr ""

#: src/Chapter3/c3p5.md:121
msgid ""
"Не гнушайтесь смотреть чужие деревья. Вы не можете сходу все знать. Делайте "
"по примеру других и чуть-чуть вносите свою лепту, если это требуется. И "
"сохраняйте авторство! :)"
msgstr ""

#: src/Chapter4/c4p0.md:3
msgid "В этой главе мы расскажем о:"
msgstr ""

#: src/Chapter4/c4p0.md:5
msgid ""
"* обновлении проприетарных библиотек устройства;\n"
"* патчинге проприетарных библиотек;\n"
"* обновлении компонентов дерева;\n"
"* работе с sepolicy;\n"
"* обновлении и сборке ядра."
msgstr ""

#: src/Chapter4/c4p0.md:11
msgid ""
"Со всем этим Вы столкнетесь в своей \"карьере\" сопровождающего "
"Android-устройства. Можно задать резонный вопрос: \"Зачем обновлять "
"что-либо, если оно и так работает?\" Android не стоит на месте, как и "
"кастомные прошивки, требуется следить за новшествами и за обновлением "
"различных специфичных компонентов вашего устройства, как ядро, дерево и "
"библиотеки - все это постоянно или с переменным успехом обновляется. К "
"примеру, в плане ядра Linux выходят новые версии ядер с исправлениями и "
"улучшениями, а также CAF постоянно полирует код для своих процессоров. Если "
"мы говорим про патчинг, то есть такая проблема, что некоторые проприетарные "
"библиотеки крайне специфичны и их ничем подменить нельзя. Приходится их "
"патчить, чтобы они работали с более новой версией Android."
msgstr ""

#: src/Chapter4/c4p1.md:1
msgid "# Параграф 1: Дампы, vendor, proprietary-files.txt и обновление библиотек"
msgstr ""

#: src/Chapter4/c4p1.md:3
msgid ""
"Здесь мы начнем говорить о том, что такое дампы, где их взять и как "
"взаимосвязаны vendor и proprietary-files.txt. Уточню, что здесь будет речь "
"не о разделе vendor, а о vendor tree, для краткости я буду писать просто "
"vendor."
msgstr ""

#: src/Chapter4/c4p1.md:5
msgid "Начнем с конца."
msgstr ""

#: src/Chapter4/c4p1.md:7
msgid "### Vendor и proprietary-files.txt"
msgstr ""

#: src/Chapter4/c4p1.md:9
msgid ""
"В деревьях вы могли видеть файлик **proprietary-files.txt**. Если вы его "
"открывали, то видели, что это по факту список того, что лежит в vendor'е. "
"Также подобных файлов может быть несколько. В деревьях устройств на базе "
"процессоров Qualcomm Snapdragon часто можно было встретить "
"**proprietary-files-qc.txt** - это список файлов для common vendor. К "
"примеру, у mido и tissot был common vendor и в их деревьях можно было "
"встретить proprietary-files-qc.txt."
msgstr ""

#: src/Chapter4/c4p1.md:11
msgid ""
"Здесь я приведу синтаксис данных списков. Позже вы поймете зачем и почему."
msgstr ""

#: src/Chapter4/c4p1.md:13
msgid "**Синтаксис строки выглядит так:**"
msgstr ""

#: src/Chapter4/c4p1.md:15
msgid ""
"```\n"
"[-]source[:destination][|sha1sum]\n"
"```"
msgstr ""

#: src/Chapter4/c4p1.md:19
msgid ""
"`-`  - если блоб является модулем, и требуется что-то собрать с "
"использованием этого блоба, "
"[пример](https://github.com/LineageOS/android_device_leeco_s2/blob/1c12856e5c8d70e756aa48f91d1ad9066ddd9fd0/audio_amplifier/Android.mk#L26)"
msgstr ""

#: src/Chapter4/c4p1.md:21
msgid ""
"`source` - из какого места был взят блоб и, если `:destination` нет, то где "
"будет лежать в готовом вендоре"
msgstr ""

#: src/Chapter4/c4p1.md:23
msgid "`destination` - где будет лежать блоб в готовом vendor'е"
msgstr ""

#: src/Chapter4/c4p1.md:25
msgid "`sha1sum` - sha1 хеш-сумма"
msgstr ""

#: src/Chapter4/c4p1.md:27
msgid ""
"Таким образом, файл **proprietary-files.txt** является списком файлов и "
"библиотек, которые нужно скопировать в директорию vendor при сборке системы. "
"Эти файлы обычно являются частью проприетарного кода или библиотек, которые "
"не могут быть распространены свободно. Они нужны для того, чтобы устройство "
"работало корректно и могло использовать все свои функции."
msgstr ""

#: src/Chapter4/c4p1.md:29
msgid "[Референс](https://wiki.lineageos.org/proprietary_blobs)"
msgstr ""

#: src/Chapter4/c4p1.md:31
msgid "### Дампы"
msgstr ""

#: src/Chapter4/c4p1.md:33
msgid ""
"Дамп - (dump) - разобранная прошивка на файлы, благодаря чему есть "
"возможность достать любой файл и что-либо с ним сделать. Дампы можно сделать "
"с помощью различных дамперов:"
msgstr ""

#: src/Chapter4/c4p1.md:35
msgid ""
"* [payload_dumper](https://github.com/vm03/payload_dumper);\n"
"* [dumpyara](https://github.com/sebaubuntu-python/dumpyara)."
msgstr ""

#: src/Chapter4/c4p1.md:38
msgid ""
"Так же Вы можете найти готовые дампы на просторах интернета. К сожалению, мы "
"не можем предоставить ссылки на репозитории с дампами. Но если поспрашивать "
"сообщество, Вы найдете все необходимое :)"
msgstr ""

#: src/Chapter4/c4p5.md:1
msgid "# Параграф 5: Обновление и сборка ядра"
msgstr ""

#: src/Chapter4/c4p5.md:3
msgid ""
"Для обновления ядра, вам нужен хотя бы средний уровень знаний того, как же "
"работает ядро (см. [что такое "
"ядро](https://github.com/Roker2/BookAboutBuilding/blob/master/%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%203%20%D0%B8%D0%B7%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B8%D1%81%D1%85%D0%BE%D0%B4%D0%BD%D0%B8%D0%BA%D0%BE%D0%B2%20%D1%83%D1%81%D1%82%D1%80%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0/%D0%9F%D0%B0%D1%80%D0%B0%D0%B3%D1%80%D0%B0%D1%84%204%20%D0%A7%D1%82%D0%BE%20%D1%82%D0%B0%D0%BA%D0%BE%D0%B5%20%D1%8F%D0%B4%D1%80%D0%BE.md#%D0%BF%D0%B0%D1%80%D0%B0%D0%B3%D1%80%D0%B0%D1%84-4-%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D1%8F%D0%B4%D1%80%D0%BE)) "
"и в целом Android, а так же умение пользоваться git (см. [ходовые команды "
"git](https://github.com/Roker2/BookAboutBuilding/blob/master/%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%202%20git%2C%20%D1%81%20%D1%87%D0%B5%D0%BC%20%D0%B5%D0%B3%D0%BE%20%D0%B5%D0%B4%D1%8F%D1%82%20%D0%B8%20%D0%B7%D0%B0%D1%87%D0%B5%D0%BC%20%D0%BE%D0%BD/%D0%9F%D0%B0%D1%80%D0%B0%D0%B3%D1%80%D0%B0%D1%84%202%20%D0%A5%D0%BE%D0%B4%D0%BE%D0%B2%D1%8B%D0%B5%20%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B%20git'%D0%B0.md#%D0%BF%D0%B0%D1%80%D0%B0%D0%B3%D1%80%D0%B0%D1%84-2-%D1%85%D0%BE%D0%B4%D0%BE%D0%B2%D1%8B%D0%B5-%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B-git%D0%B0))."
msgstr ""

#: src/Chapter4/c4p5.md:5
msgid "## Обновление"
msgstr ""

#: src/Chapter4/c4p5.md:7
msgid "### Подготовка"
msgstr ""

#: src/Chapter4/c4p5.md:9
msgid ""
"Давайте, для начала узнаем какие стабильные версии ядра Android на данный "
"момент (2022 г.) активно обновляются. Вот список для наглядности: *4.9, "
"4.14, 4.19, 5.4, 5.10, 5.15*. Должен сразу предупредить, что обновить ядро, "
"предположим, с 4.9 до 4.19 без перебазирования невозможно, более того, "
"обычно производитель делает специфические драйвера устройства только для "
"одной версии и не обновляет дальше, а так же само ядро может не поддерживать "
"ваш чипсет и без углублённых знаний в ядре обновить драйвера у вас не "
"получится. Поэтому, зачастую, маинтейнеры обновляют **sublevel** ядра, это "
"мы и будем делать ниже. Чтобы узнать его, заходим в исходник ядра, которое "
"хотим обновить, в корне находим и открываем файлик **Makefile**, в самом "
"верху (обычно) видим такую картину:"
msgstr ""

#: src/Chapter4/c4p5.md:11
msgid ""
"<p align=\"center\">\n"
"  <img src=\"../Chapter4/images/1.png\"/>\n"
"</p>"
msgstr ""

#: src/Chapter4/c4p5.md:15
msgid ""
"> *Либо просто заходим на своём смартфоне в Настройки > О Телефоне (только "
"если на смартфоне установлено то же ядро, исходники которого вы собираететсь "
"обновить*)"
msgstr ""

#: src/Chapter4/c4p5.md:17
msgid ""
"Узнали. После этого нужно найти репозиторий общего (common) ядра, с которого "
"и будем обновлять, обычно используют "
"https://android.googlesource.com/kernel/common/, но можно и другие зеркала. "
"Например https://git.codelinaro.org/clo/la/kernel/msm (только для Qualcomm)."
msgstr ""

#: src/Chapter4/c4p5.md:19
msgid "Смотрим в список бранчей и выбираем со своей версией ядра:"
msgstr ""

#: src/Chapter4/c4p5.md:21
msgid ""
"<p align=\"center\">\n"
"  <img src=\"../Chapter4/images/2.png\"/>\n"
"</p>"
msgstr ""

#: src/Chapter4/c4p5.md:25
msgid ""
"После чего смотрим на название последнего коммита, должно быть что-то по "
"типу `Merge <версия ядра>`, если sublevel выше, чем в ваших в исходниках, "
"тогда можно продолжать. Если же нет, то поздравляю, у вас последняя версия"
msgstr ""

#: src/Chapter4/c4p5.md:29
msgid "### Скачиваем репозитории"
msgstr ""

#: src/Chapter4/c4p5.md:31
msgid ""
"Для примера, я буду использовать "
"[4.9.268](https://github.com/PixelExperience-Devices/kernel_lenovo_sdm710/tree/81bad83b39681cc137d99a1b613839032dab9184) "
"ядро от Lenovo Z5s (jd2019) и обновлю его до "
"[4.9.319](https://github.com/PixelExperience-Devices/kernel_lenovo_sdm710/tree/76e4fbb527d37378bac0a982c3df9551f17dbfe7). "
"Также, для удобства, рекомендую использовать [GitHub  "
"Desktop](https://github.com/shiftkey/desktop), хоть в нём и не присутствует "
"весь функционал."
msgstr ""

#: src/Chapter4/c4p5.md:33
msgid ""
"1. Для начала нам нужно склонировать исходники своего ядра (описывать как "
"это делать я думаю не нужно), после добавляем репозиторий в GitHub Desktop "
"(опять же, это не обязательно, все действия можно выполнить только через "
"git).\n"
"\n"
"2. Затем, открываем терминал в папке с исходниками вашего ядра и добавляем "
"наш удаленный репозиторий общего ядра командой:\n"
"   ```bash\n"
"   git remote add common url \n"
"   ```\n"
"\n"
"   `common` - название, можете использовать любое другое\n"
"   `url` - ссылка на репозиторий\n"
"\n"
"3. Теперь фетчим добавленный репозиторий:\n"
"   ```bash\n"
"   git fetch common\n"
"   ```\n"
"   > *Если вам лень или не позволяет интернет скачать весь репозиторий, "
"можете в конце команды добавить название бранча, тогда скачивать будет "
"только его.*"
msgstr ""

#: src/Chapter4/c4p5.md:49
msgid "### Мержим изменения"
msgstr ""

#: src/Chapter4/c4p5.md:51
msgid ""
"Обновлять ядро лучше всего по одному саблевелу - так больший шанс понять в "
"какой версии и коммите проблема, если у вас будут ошибки при сборке, либо в "
"самой системе, я же рисковый и делал сразу по пять (о чём потом пожалел)."
msgstr ""

#: src/Chapter4/c4p5.md:53
msgid ""
"1. Находим нужную нам версию с помощью поиска в разделе тэгов:\n"
"   <p align=\"center\">\n"
"     <img src=\"../Chapter4/images/4.png\"/>\n"
"   </p>\n"
"\n"
"2. Копируем SHA и мержим этот коммит в нашем бранче:\n"
"   ```bash\n"
"   git merge sha\n"
"   ```\n"
"   > Если никаких конфликтов нет, то можете замержить ещё пару. Но опять же, "
"вы не будете знать на какой версии у вас всё поломалось, так что лучше "
"мержить по одному-два и собирать, если ядро собралось и система запустилась, "
"то переходим к следующим саблевелам."
msgstr ""

#: src/Chapter4/c4p5.md:64
msgid "### Фиксим конфликты"
msgstr ""

#: src/Chapter4/c4p5.md:66
msgid ""
"Здесь всё довольно муторно. Лично я делаю по такой схеме: если появляются "
"конфликты, то открываю GitHub Desktop, с помощью него намного легче найти "
"их, т.к. они все сразу отображаются вместе с поломанными строками. Если "
"конфликт простой, то фикшу вручную, если же ничего не понятно, то захожу в "
"common репо, открываю просмотр файлов во временной точке нужного тэга и ищу "
"этот конфликтный файл там, открываю историю коммитов для него и смотрю как "
"делали там и просто повторяю все изменения в свой файл. Конфликтных файлов "
"может быть очень много, так что наберитесь терпения и не спешите, т.к. одна "
"лишняя строчка или ошибка в тексте и ядро у вас не соберётся, либо не "
"запустится."
msgstr ""

#: src/Chapter4/c4p5.md:70
msgid "## Сборка ядра"
msgstr ""

#: src/Chapter4/c4p5.md:73
msgid "### Из исходников прошивки "
msgstr ""

#: src/Chapter4/c4p5.md:75
msgid ""
"Этот способ для тех, кто уже знает как собирать прошивки и т.п. Проходим по "
"обычному сценарию подготовки к сборке прошивки, только вместо команды "
"запуска сборки прошивки (`mka bacon`, `make bacon` и др.), пишем `mka "
"bootimage`."
msgstr ""

#: src/Chapter4/c4p5.md:77
msgid "### Из папки ядра"
msgstr ""

#: src/Chapter4/c4p5.md:79
msgid ""
"1. Скачайте исходный код ядра Android и перейдите в папку с ним с помощью "
"команды:\n"
"\n"
"   ```bash\n"
"   git clone <url> kernel\n"
"   ```\n"
"   ```bash\n"
"   cd kernel\n"
"   ```\n"
"\n"
"2. Убедитесь, что у вас установлены необходимые инструменты для сборки ядра, "
"такие как компилятор GCC/Clang, библиотека make, инструменты для работы с "
"архивами (tar, gzip и т.д.) и другие.\n"
"\n"
"\n"
"3. Выберите конфигурацию ядра, которую хотите собрать:\n"
"   ```bash\n"
"   make defconfig\n"
"   ```\n"
"   > Эта команда создаст файл конфигурации ядра с набором опций по "
"умолчанию. Конечно же, выбираете свой defconfig\n"
"   ```bash\n"
"   make menuconfig\n"
"   ```\n"
"   > Эта команда откроет интерактивное меню, где вы сможете выбрать нужные "
"опции ядра с помощью стрелочек.\n"
"\n"
"4. Запустите сборку ядра с помощью команды:\n"
"   ```bash\n"
"   make -jN\n"
"   ```\n"
"   > Где N - это количество ядер вашего процессора. Это позволит ускорить "
"сборку, так как она будет выполняться параллельно на разных ядрах.\n"
"\n"
"5. После успешной сборки ядро будет доступно в каталоге "
"`arch/architecture/boot/` (где architecture - это архитектура вашего "
"устройства, например, x86 или arm)."
msgstr ""

#: src/Chapter5/c5p1.md:1
#: src/Chapter5/c5p1.md:1
msgid "# Параграф 1: ошибки сборки (SELinux, нехватка пакетов, ресурсов и тд)"
msgstr ""

#: src/Chapter5/c5p1.md:5
#: src/Chapter5/c5p1.md:5
msgid "## Cписок частых ошибок:"
msgstr ""

#: src/Chapter5/c5p1.md:7
#: src/Chapter5/c5p1.md:7
msgid ""
"1. [ccache](#ccache)\n"
"\n"
"2. [libncurses5](#libncurses5)\n"
"\n"
"3. [metalava](#Metalava) \n"
"\n"
"4. "
"[UnicodeDecodeError](#unicodedecodeerror-ascii-codec-cant-decode-byte-0xd0)"
msgstr ""

#: src/Chapter5/c5p1.md:17
#: src/Chapter5/c5p1.md:17
msgid "### ccache"
msgstr ""

#: src/Chapter5/c5p1.md:19
#: src/Chapter5/c5p1.md:19
msgid ""
"`error: Failed to create directory /home/user/.ccache/tmp: Read -only file "
"system`"
msgstr ""

#: src/Chapter5/c5p1.md:21
#: src/Chapter5/c5p1.md:21
msgid ""
"> Фикс:\n"
">\n"
"> 1. Создаём папку по пути /mnt/ccache командой:\n"
"> \t```bash\n"
"> \tsudo mkdir /mnt/ccache\n"
"> \t```\n"
"> 2. Монтируем cache:\n"
"> \t```bash\n"
"> \tsudo mount --bind /home/username/.cache /mnt/ccache\n"
"> \t```\n"
"> \t*Вместо \"username\" вписываете своего юзера! И не ошибитесь в пути, у "
"вас он может быть слегка другим.*\n"
">\n"
"> 3. После монтирования прописываем команду для сжатия нашего кэша (это "
"опционально, если вы хотите впихнуть больше в мелкий объём как я, то "
"пишем):\n"
"> \t```bash\n"
"> \tccache -o compression=true\n"
"> \t```\n"
"> 4. Делаем стандартный экспорт и т.д.:\n"
">    ```bash\n"
">    export USE_CCACHE=1\n"
">    ```\n"
">    ```bash\n"
">    export CCACHE_EXEC=/usr/bin/ccache\n"
">    ```\n"
">    ```bash\n"
">    export CCACHE_DIR=/mnt/ccache\n"
">    ```\n"
"> 5. Устанавливаем размер нашего кэша:\n"
"> \t```bash\n"
"> \tccache -M 15G -F 0\n"
"> \t```\n"
"> \t*15G - Размер кэша в ГБ*\n"
"> \t\t\t\n"
"> \t5.1. **Такое решение работает до первой перезагрузки.** Для повторного "
"исправления (после каждого ребута), просто прописываете команду "
"монтирования:\n"
">\t```bash\n"
"> \tsudo mount --bind /home/username/.cache /mnt/ccache\n"
"> \t```\n"
"> 6. Либо добавляем наш ccache в fstab:\n"
"> \t```bash\n"
"> \tsudo nano /etc/fstab\n"
"> \t```\n"
">\t6.1. И добавляем строку:\n"
"> \t   `/home/username/ccache /mnt/ccache none defaults,bind,users,noauto 0 "
"0`\n"
">\n"
"> 8. После чего редактируем файл профиля:\n"
"> \t```bash\n"
">\tnano ~/.profile\n"
"> \t```\n"
"> \t7.1.  Добавив строку:\n"
"> \t   ```bash\n"
"> \t   mount /mnt/ccache\n"
"> \t   ```"
msgstr ""

#: src/Chapter5/c5p1.md:75
#: src/Chapter5/c5p1.md:75
msgid "### libncurses5"
msgstr ""

#: src/Chapter5/c5p1.md:77
#: src/Chapter5/c5p1.md:77
msgid ""
"`error while loading shared libraries: libncurses.so.5: cannot open shared "
"object file: No such file or directory`"
msgstr ""

#: src/Chapter5/c5p1.md:79
#: src/Chapter5/c5p1.md:79
msgid ""
"> Фикс:\n"
">\n"
"> - Ubuntu\n"
">\n"
">   ```bash\n"
">   sudo apt-get install libncurses5\n"
">   ```\n"
">\n"
"> - Arch\n"
">\n"
">   ```bash\n"
">   yay ncurses5-compat-libs\n"
">   ```"
msgstr ""

#: src/Chapter5/c5p1.md:93
#: src/Chapter5/c5p1.md:93
msgid "### Metalava"
msgstr ""

#: src/Chapter5/c5p1.md:94
#: src/Chapter5/c5p1.md:94
msgid ""
"`Симптомы: Сборка останавливается с ошибкой об нехватке ОЗУ на этапе сборки "
"Metalava, либо надолго зависает`"
msgstr ""

#: src/Chapter5/c5p1.md:96
#: src/Chapter5/c5p1.md:96
msgid ""
"> Фикс:\n"
">\n"
"> **Android 10** *(возможно устарело)*\n"
">\n"
"> 1) Заходим в папку build/soong:\n"
">\n"
"> ```bash\n"
"> cd build/soong\n"
"> ```\n"
">\n"
"> 2) Открываем на Lineage OS Gerrit нужный нам "
"[коммит](https://review.lineageos.org/c/LineageOS/android_build_soong/+/266411)\n"
">\n"
"> 3) Нажимаем кнопку \"`DOWNLOAD`\"\n"
">\n"
"> > <p align=\"center\">\n"
">   <img src=\"../Chapter5/images/2.png\"/>\n"
"> </p>\n"
">\n"
"> 4) Напротив варианта \"`Cherry Pick`\" нажимаем кнопку копирования\n"
"> <p align=\"center\">\n"
">   <img src=\"../Chapter5/images/3.png\"/>\n"
"> </p>\n"
">\n"
"> 5) Копируем в терминал и нажимаем Enter\n"
">\n"
"> 6) Возвращаемся в корень исходников:\n"
">\n"
"> ```bash\n"
"> cd ../..\n"
"> ```\n"
">\n"
"> 7) Выполняем все подготовительные команды для сборки, но не запускаем\n"
">\n"
"> 8) Заранее и отдельно собираем по одному компоненту, который требует много "
"ОЗУ:\n"
">\n"
"> ```bash\n"
"> mka api-stubs-docs && mka hiddenapi-lists-docs && mka "
"system-api-stubs-docs && mka test-api-stubs-docs\n"
"> ```\n"
">\n"
"> 9) Запускаем сборку прошивки\n"
">\n"
"> "
"[Референс](https://gist.github.com/mikecriggs/d98f2fc3461b23732fabebb020e4c42e)\n"
">\n"
"> \n"
">\n"
"> **Android 11-13**\n"
">\n"
"> Для него все тоже самое, отличие только в "
"[коммите](https://github.com/verNANDo57/android_build_soong/commit/ffc8846a01fcfc20d6cf8ca701ef73d99f15acad) "
"и какие компоненты собираем заранее.\n"
">\n"
"> ```bash\n"
"> mka api-stubs-docs && mka module-lib-api-stubs-docs && mka "
"system-api-stubs-docs && mka test-api-stubs-docs\n"
"> ```\n"
">\n"
"> "
"[Референс](https://gist.github.com/verNANDo57/d76bb6e6e4b887101cf5a1cf64c66cef)"
msgstr ""

#: src/Chapter5/c5p1.md:152
#: src/Chapter5/c5p1.md:152
msgid "### UnicodeDecodeError: 'ascii' codec can't decode byte 0xd0"
msgstr ""

#: src/Chapter5/c5p1.md:154
#: src/Chapter5/c5p1.md:154
msgid ""
"<p align=\"center\">\n"
"  <img src=\"../Chapter5/images/1.png\"/>\n"
"</p>"
msgstr ""

#: src/Chapter5/c5p1.md:158
#: src/Chapter5/c5p1.md:158
msgid ""
"> Фикс:\n"
">\n"
"> ​\tУбрать русские буквы в пути. Не должно быть по типу "
"/home/coolgirl/прошивочка/..."
msgstr ""

#: src/Chapter5/c5p5.md:1
msgid "# Список полезных утилит и приложений"
msgstr ""

#: src/Chapter5/c5p5.md:3
msgid ""
"* [GitHub Desktop](https://github.com/shiftkey/desktop) - GUI клиент GitHub "
"для быстрого редактирования репозитория, отсутствуют некоторые важные "
"функции, поэтому работать с консолью все равно придётся\n"
"\n"
"* [GitKraken](https://www.gitkraken.com/) - GUI git клиент\n"
"\n"
"* Midnight Commander - консольный файловый менеджер, пакет `mc`\n"
"\n"
"* [Meld](https://meld.app/) - программа для сравнения файлов, пакет `meld`\n"
"\n"
"* nano - консольный текстовый редактор\n"
"\n"
"* sed - потоковый текстовый редактор"
msgstr ""

